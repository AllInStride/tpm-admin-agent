---
phase: 08-meeting-prep
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/prep/__init__.py
  - src/prep/schemas.py
  - src/prep/item_matcher.py
  - src/adapters/calendar_adapter.py
  - tests/prep/test_schemas.py
  - tests/prep/test_item_matcher.py
  - tests/adapters/test_calendar_adapter_extended.py
autonomous: true

must_haves:
  truths:
    - "Calendar adapter can list upcoming events in a time window"
    - "Item matcher returns open items matching attendees AND project"
    - "Items prioritized: overdue first, then by type (action > risk > issue > decision)"
  artifacts:
    - path: "src/prep/schemas.py"
      provides: "PrepConfig, PrepSummary, MeetingPrepRequest data models"
      contains: "class PrepConfig"
    - path: "src/prep/item_matcher.py"
      provides: "Item matching and prioritization for prep"
      exports: ["ItemMatcher", "prioritize_items"]
    - path: "src/adapters/calendar_adapter.py"
      provides: "Extended with list_upcoming_events method"
      contains: "async def list_upcoming_events"
  key_links:
    - from: "src/prep/item_matcher.py"
      to: "src/repositories/open_items_repo.py"
      via: "get_items_for_prep query"
      pattern: "OpenItemsRepository"
    - from: "src/adapters/calendar_adapter.py"
      to: "Google Calendar API"
      via: "events().list()"
      pattern: "events.*list"
---

<objective>
Create prep schemas, extend CalendarAdapter with event listing, and build ItemMatcher for attendee+project item retrieval.

Purpose: Establish the data models and core query infrastructure for meeting prep. CalendarAdapter needs to list upcoming meetings. ItemMatcher needs to find relevant open items by attendee overlap AND project association per CONTEXT.md.

Output: Prep schemas, extended CalendarAdapter, ItemMatcher service with prioritization logic.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-meeting-prep/08-CONTEXT.md
@.planning/phases/08-meeting-prep/08-RESEARCH.md
@src/repositories/open_items_repo.py
@src/adapters/calendar_adapter.py
@src/search/open_items.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Prep schemas and CalendarAdapter extension</name>
  <files>
    - src/prep/__init__.py
    - src/prep/schemas.py
    - src/adapters/calendar_adapter.py
    - tests/prep/test_schemas.py
    - tests/adapters/test_calendar_adapter_extended.py
  </files>
  <action>
Create `src/prep/` module with schemas:

**src/prep/schemas.py:**
- `PrepConfig`: Pydantic model with `lead_time_minutes: int = 10`, `delivery_method: Literal["slack", "email"] = "slack"`, `max_items: int = 10`, `lookback_days: int = 90`
- `CalendarEvent`: Model for calendar events with `id`, `summary`, `start` (datetime), `end` (datetime), `attendees: list[dict]` (each has email, displayName, responseStatus)
- `PrepItem`: Open item formatted for prep with `id`, `item_type`, `description`, `owner`, `due_date`, `is_overdue: bool`, `is_new: bool` (since last meeting)
- `TalkingPoint`: Simple model with `text: str`, `category: Literal["overdue", "risk", "new_item", "general"]`
- `PrepSummary`: Full prep package with `meeting: CalendarEvent`, `open_items: list[PrepItem]`, `talking_points: list[TalkingPoint]`, `recent_meeting_url: str | None`, `full_prep_url: str | None`, `attendees: list[dict]` (name, role)
- `MeetingPrepRequest`: API request with `calendar_id: str`, `event_id: str`, `project_id: str`

**Extend src/adapters/calendar_adapter.py:**
Add `list_upcoming_events(calendar_id: str, time_min: datetime, time_max: datetime, max_results: int = 50) -> list[dict]` method:
- Uses `service.events().list()` with timeMin, timeMax, maxResults, singleEvents=True, orderBy='startTime'
- Returns list of event dicts with id, summary, start, end, attendees
- Handle errors gracefully (log and return empty list)
- Use `asyncio.to_thread` for non-blocking since google API is sync

**Tests:**
- test_schemas.py: Validation tests for all Pydantic models
- test_calendar_adapter_extended.py: Mock google API for list_upcoming_events (success, empty, error cases)
  </action>
  <verify>
`pytest tests/prep/test_schemas.py tests/adapters/test_calendar_adapter_extended.py -v` passes
  </verify>
  <done>
PrepConfig, CalendarEvent, PrepItem, TalkingPoint, PrepSummary, MeetingPrepRequest schemas validated; CalendarAdapter.list_upcoming_events returns events in time window
  </done>
</task>

<task type="auto">
  <name>Task 2: ItemMatcher with attendee+project filtering</name>
  <files>
    - src/prep/item_matcher.py
    - tests/prep/test_item_matcher.py
  </files>
  <action>
Create `src/prep/item_matcher.py`:

**ItemMatcher class:**
- Constructor: `__init__(self, db_client: TursoClient)`
- Method: `get_items_for_prep(attendee_emails: list[str], project_id: str, lookback_days: int = 90) -> list[dict]`
  - Query raid_items_projection for open items (status NOT IN closed statuses)
  - Match by BOTH criteria per CONTEXT.md:
    1. owner email in attendee_emails list, OR
    2. meeting_id in meetings where any attendee_emails were present
  - Scope to items created within lookback_days
  - Return items with: id, meeting_id, item_type, description, owner, due_date, status, confidence, created_at, is_overdue (computed)
  - Use CLOSED_STATUSES from src/search/open_items.py

**prioritize_items function:**
- Signature: `prioritize_items(items: list[dict], max_items: int = 10, last_meeting_date: datetime | None = None) -> list[dict]`
- Sort order per CONTEXT.md:
  1. Overdue items first (is_overdue = True)
  2. Then by type order: action=0, risk=1, issue=2, decision=3
  3. Then by due_date ascending (nulls last)
- Mark `is_new = True` for items created after last_meeting_date
- Truncate to max_items
- Return prioritized list

**generate_talking_points function:**
- Signature: `generate_talking_points(items: list[dict], max_points: int = 3) -> list[TalkingPoint]`
- Heuristic approach per RESEARCH.md:
  - If overdue items exist: "Review {N} overdue items" (category: overdue)
  - If high-severity risks exist: "Discuss risk: {description[:50]}" (category: risk)
  - If new items since last meeting: "{N} new items since last meeting" (category: new_item)
  - Generic fallback: "Status update on open action items" (category: general)
- Return 2-3 points max

**Tests (test_item_matcher.py):**
- Test get_items_for_prep with mock DB (attendee match, project match, both)
- Test prioritize_items sorting (overdue first, type order, due date order)
- Test is_new marking based on last_meeting_date
- Test max_items truncation
- Test generate_talking_points heuristics
- Edge cases: empty items, all closed, no attendee match
  </action>
  <verify>
`pytest tests/prep/test_item_matcher.py -v` passes with all edge cases covered
  </verify>
  <done>
ItemMatcher.get_items_for_prep returns items matching attendees AND project; prioritize_items sorts overdue > type > due_date; generate_talking_points produces 2-3 heuristic points
  </done>
</task>

</tasks>

<verification>
- `pytest tests/prep/ tests/adapters/test_calendar_adapter_extended.py -v` all pass
- `ruff check src/prep/ src/adapters/calendar_adapter.py` no errors
- CalendarAdapter can list events in a time window
- ItemMatcher returns filtered, prioritized items
</verification>

<success_criteria>
1. PrepConfig allows configurable lead time (default 10 min), delivery method, max items (10), lookback (90 days)
2. CalendarAdapter.list_upcoming_events returns events between time_min and time_max
3. ItemMatcher.get_items_for_prep returns open items where owner is attendee OR meeting had attendees
4. prioritize_items sorts: overdue first, then action > risk > issue > decision, then by due_date
5. generate_talking_points returns 2-3 context-aware suggestions
6. All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-meeting-prep/08-01-SUMMARY.md`
</output>
