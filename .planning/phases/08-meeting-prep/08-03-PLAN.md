---
phase: 08-meeting-prep
plan: 03
type: execute
wave: 2
depends_on: ["08-01", "08-02"]
files_modified:
  - src/prep/prep_service.py
  - src/prep/scheduler.py
  - src/prep/formatter.py
  - src/api/prep.py
  - src/api/router.py
  - src/main.py
  - pyproject.toml
  - tests/prep/test_prep_service.py
  - tests/prep/test_scheduler.py
  - tests/prep/test_formatter.py
  - tests/api/test_prep_api.py
autonomous: true

must_haves:
  truths:
    - "PrepService scans for upcoming meetings and sends prep summaries"
    - "Scheduler runs every 5 minutes to check for meetings starting in 10-15 min window"
    - "Prep summaries delivered via Slack DM with Block Kit formatting"
    - "Duplicate preps prevented (same meeting not prepped twice)"
  artifacts:
    - path: "src/prep/prep_service.py"
      provides: "PrepService orchestrates prep generation and delivery"
      exports: ["PrepService"]
    - path: "src/prep/scheduler.py"
      provides: "APScheduler integration for periodic meeting scanning"
      exports: ["prep_scheduler_lifespan", "get_scheduler"]
    - path: "src/prep/formatter.py"
      provides: "Block Kit formatter for Slack prep messages"
      exports: ["format_prep_blocks", "format_prep_text"]
    - path: "src/api/prep.py"
      provides: "API endpoints for prep management"
      contains: "router = APIRouter"
  key_links:
    - from: "src/prep/prep_service.py"
      to: "src/prep/context_gatherer.py"
      via: "gather_for_meeting call"
      pattern: "context_gatherer.*gather_for_meeting"
    - from: "src/prep/prep_service.py"
      to: "src/adapters/slack_adapter.py"
      via: "send_prep_dm call"
      pattern: "slack.*send_prep_dm"
    - from: "src/main.py"
      to: "src/prep/scheduler.py"
      via: "lifespan context manager"
      pattern: "prep_scheduler_lifespan"
---

<objective>
Create PrepService to orchestrate prep generation, APScheduler for periodic scanning, Block Kit formatter, and API endpoints.

Purpose: Complete the meeting prep pipeline. PrepService coordinates context gathering and delivery. Scheduler runs every 5 minutes checking for meetings starting in 10-15 min. Formatter creates scannable Block Kit messages per CONTEXT.md. API allows manual prep triggers and configuration.

Output: Working meeting prep system that scans calendar and delivers prep summaries before meetings.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-meeting-prep/08-CONTEXT.md
@.planning/phases/08-meeting-prep/08-RESEARCH.md
@.planning/phases/08-meeting-prep/08-01-SUMMARY.md
@.planning/phases/08-meeting-prep/08-02-SUMMARY.md
@src/main.py
@src/api/router.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Block Kit formatter and PrepService</name>
  <files>
    - src/prep/formatter.py
    - src/prep/prep_service.py
    - tests/prep/test_formatter.py
    - tests/prep/test_prep_service.py
  </files>
  <action>
**Create src/prep/formatter.py:**

**format_prep_blocks function:**
```python
def format_prep_blocks(
    meeting_title: str,
    attendees: list[dict],  # {name, role}
    open_items: list[dict],  # PrepItem-like dicts
    talking_points: list[str],
    recent_meeting_url: str | None = None,
    full_prep_url: str | None = None,
) -> list[dict]:
```
Per CONTEXT.md requirements:
- Scannable (fits one screen)
- Header block with meeting title
- Attendees section: "Name (Role)" comma-separated
- Divider
- Overdue items section (if any) with :warning: emoji prefix
- Open items section with compact format: "description[:50] | owner | due_date"
- NEW items marked with "*NEW* " prefix (is_new=True)
- Divider
- Talking points as bullet list (2-3 max)
- Context block with links (Recent Meeting Notes | View Full Prep)

**format_prep_text function:**
```python
def format_prep_text(
    meeting_title: str,
    open_items: list[dict],
    talking_points: list[str],
) -> str:
```
- Plain text fallback for Slack notifications
- Concise: "Meeting Prep: {title}\n{N} open items, {M} overdue\nTop talking point: {point}"

**Create src/prep/prep_service.py:**

**PrepService class:**
```python
class PrepService:
    _instance: "PrepService | None" = None

    def __init__(
        self,
        calendar_adapter: CalendarAdapter,
        slack_adapter: SlackAdapter,
        item_matcher: ItemMatcher,
        context_gatherer: ContextGatherer,
        config: PrepConfig | None = None,
    ):
        self._calendar = calendar_adapter
        self._slack = slack_adapter
        self._item_matcher = item_matcher
        self._context_gatherer = context_gatherer
        self._config = config or PrepConfig()
        self._sent_preps: set[str] = set()  # track sent: "event_id:date"

    @classmethod
    def get_instance(cls) -> "PrepService":
        if cls._instance is None:
            raise RuntimeError("PrepService not initialized")
        return cls._instance

    @classmethod
    def set_instance(cls, instance: "PrepService") -> None:
        cls._instance = instance
```

**scan_and_prepare method:**
```python
async def scan_and_prepare(self, calendar_id: str = "primary") -> list[dict]:
```
- Calculate time window: now + lead_time to now + lead_time + 5min
- Call calendar_adapter.list_upcoming_events(calendar_id, time_min, time_max)
- For each meeting:
  - Generate prep_key: f"{event_id}:{start_date}"
  - Skip if prep_key in _sent_preps (prevent duplicates)
  - Call prepare_for_meeting
  - Add to _sent_preps on success
- Return list of sent prep results

**prepare_for_meeting method:**
```python
async def prepare_for_meeting(
    self,
    event: dict,
    project_id: str,
    project_folder_id: str | None = None,
    slack_channel_id: str | None = None,
) -> dict:
```
- Convert event to CalendarEvent schema
- Call context_gatherer.gather_for_meeting
- Call item_matcher prioritize_items on gathered items
- Call item_matcher generate_talking_points
- Format with format_prep_blocks
- For each attendee with email:
  - Look up Slack user ID via slack_adapter.lookup_user_by_email
  - Call slack_adapter.send_prep_dm if user found
- Return summary: {"meeting_id": ..., "recipients": N, "items": M}

**Tests:**
- test_formatter.py: Test Block Kit structure, overdue section, links
- test_prep_service.py:
  - Mock all adapters
  - Test scan_and_prepare finds meetings in window
  - Test duplicate prevention (same meeting not prepped twice)
  - Test prepare_for_meeting calls context_gatherer
  - Test delivery to multiple attendees
  </action>
  <verify>
`pytest tests/prep/test_formatter.py tests/prep/test_prep_service.py -v` passes
  </verify>
  <done>
format_prep_blocks creates scannable Block Kit message; PrepService.scan_and_prepare finds upcoming meetings and sends prep; duplicate prevention works
  </done>
</task>

<task type="auto">
  <name>Task 2: APScheduler, API endpoints, and app integration</name>
  <files>
    - pyproject.toml
    - src/prep/scheduler.py
    - src/api/prep.py
    - src/api/router.py
    - src/main.py
    - src/prep/__init__.py
    - tests/prep/test_scheduler.py
    - tests/api/test_prep_api.py
  </files>
  <action>
**Update pyproject.toml:**
Add APScheduler dependency:
```toml
"apscheduler>=3.11.0,<4.0",
```

**Create src/prep/scheduler.py:**
```python
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from contextlib import asynccontextmanager
from datetime import timezone
import structlog

logger = structlog.get_logger()

_scheduler: AsyncIOScheduler | None = None

def get_scheduler() -> AsyncIOScheduler:
    global _scheduler
    if _scheduler is None:
        _scheduler = AsyncIOScheduler(timezone=timezone.utc)
    return _scheduler

@asynccontextmanager
async def prep_scheduler_lifespan():
    scheduler = get_scheduler()

    scheduler.add_job(
        scan_for_upcoming_meetings,
        'interval',
        minutes=5,
        id='meeting_prep_scanner',
        replace_existing=True,
        max_instances=1,
    )

    logger.info("Starting prep scheduler")
    scheduler.start()

    try:
        yield
    finally:
        logger.info("Shutting down prep scheduler")
        scheduler.shutdown(wait=False)

async def scan_for_upcoming_meetings():
    """Scheduled job: find meetings starting soon."""
    try:
        prep_service = PrepService.get_instance()
        results = await prep_service.scan_and_prepare()
        if results:
            logger.info("Sent meeting preps", count=len(results))
    except Exception as e:
        logger.error("Prep scan failed", error=str(e))
```

**Create src/api/prep.py:**
```python
from fastapi import APIRouter, HTTPException, Request
from src.prep.schemas import MeetingPrepRequest, PrepConfig
from src.prep.prep_service import PrepService

router = APIRouter(prefix="/prep", tags=["prep"])

@router.post("/trigger")
async def trigger_prep(request: MeetingPrepRequest) -> dict:
    """Manually trigger prep for a specific meeting."""
    prep_service = PrepService.get_instance()
    result = await prep_service.prepare_for_meeting(
        event={"id": request.event_id},  # Minimal event, will fetch details
        project_id=request.project_id,
    )
    return result

@router.post("/scan")
async def scan_now(calendar_id: str = "primary") -> dict:
    """Manually trigger a scan for upcoming meetings."""
    prep_service = PrepService.get_instance()
    results = await prep_service.scan_and_prepare(calendar_id)
    return {"scanned": True, "preps_sent": len(results), "results": results}

@router.get("/config")
async def get_config() -> PrepConfig:
    """Get current prep configuration."""
    prep_service = PrepService.get_instance()
    return prep_service._config

@router.get("/status")
async def get_status() -> dict:
    """Get scheduler status and recent activity."""
    from src.prep.scheduler import get_scheduler
    scheduler = get_scheduler()
    jobs = scheduler.get_jobs()
    return {
        "scheduler_running": scheduler.running,
        "jobs": [{"id": j.id, "next_run": str(j.next_run_time)} for j in jobs],
    }
```

**Update src/api/router.py:**
Import and include prep_router.

**Update src/main.py lifespan:**
- Import prep components
- Initialize PrepService with adapters after existing initialization
- Set PrepService.set_instance()
- Integrate prep_scheduler_lifespan using contextlib.AsyncExitStack for composable lifespans
- Add PrepConfig to settings if needed

**Update src/prep/__init__.py:**
Export all public classes and functions.

**Tests:**
- test_scheduler.py:
  - Test scheduler starts and adds job
  - Test job runs at interval (mock time)
  - Test shutdown stops scheduler
- test_prep_api.py:
  - Test POST /prep/trigger returns result
  - Test POST /prep/scan triggers scan
  - Test GET /prep/config returns config
  - Test GET /prep/status shows scheduler state
  </action>
  <verify>
`pytest tests/prep/test_scheduler.py tests/api/test_prep_api.py -v` passes; `uvicorn src.main:app --reload` starts without error and scheduler logs "Starting prep scheduler"
  </verify>
  <done>
APScheduler runs every 5 minutes scanning for meetings; API endpoints allow manual triggers and status checks; PrepService integrated into app lifespan
  </done>
</task>

</tasks>

<verification>
- `pytest tests/prep/ tests/api/test_prep_api.py -v` all pass
- `ruff check src/prep/ src/api/prep.py` no errors
- App starts: `uvicorn src.main:app` shows "Starting prep scheduler" in logs
- `curl http://localhost:8000/prep/status` returns scheduler info
- Full test suite: `pytest` passes (all existing + new tests)
</verification>

<success_criteria>
1. format_prep_blocks creates Block Kit with header, attendees, overdue items, open items, talking points, links
2. PrepService.scan_and_prepare checks calendar for meetings in 10-15 min window
3. Duplicate preps prevented via _sent_preps tracking
4. APScheduler runs scan every 5 minutes
5. POST /prep/trigger allows manual prep for specific meeting
6. POST /prep/scan triggers immediate calendar scan
7. GET /prep/status shows scheduler running state and next run time
8. App lifespan properly starts/stops scheduler
9. All tests pass including full existing suite
</success_criteria>

<output>
After completion, create `.planning/phases/08-meeting-prep/08-03-SUMMARY.md`
</output>
