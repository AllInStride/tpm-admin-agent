---
phase: 02-transcript-ingestion
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/__init__.py
  - src/services/transcript_parser.py
  - pyproject.toml
  - tests/test_transcript_parser.py
autonomous: true

must_haves:
  truths:
    - "Parser extracts speaker names from VTT voice tags"
    - "Parser extracts timestamps in seconds (float)"
    - "Parser handles SRT files without voice tags (speaker = 'Unknown Speaker')"
    - "Parser returns list of unique speakers"
    - "Parser calculates total duration"
  artifacts:
    - path: "src/services/transcript_parser.py"
      provides: "TranscriptParser class and ParsedTranscript dataclass"
      exports: ["TranscriptParser", "ParsedTranscript"]
    - path: "pyproject.toml"
      provides: "webvtt-py dependency"
      contains: "webvtt-py"
    - path: "tests/test_transcript_parser.py"
      provides: "Unit tests for parser"
      min_lines: 50
  key_links:
    - from: "src/services/transcript_parser.py"
      to: "src/models/meeting.py"
      via: "import Utterance"
      pattern: "from src\\.models\\.meeting import Utterance"
---

<objective>
Create the VTT/SRT transcript parser service with speaker diarization support.

Purpose: ING-02 and ING-03 require parsing transcript formats and identifying speakers. This plan creates a standalone parser service that converts raw transcript content into structured Utterance objects with speaker identification.

Output: TranscriptParser class that parses VTT/SRT content into ParsedTranscript containing utterances, speakers list, and duration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-transcript-ingestion/02-RESEARCH.md

# Existing models
@src/models/meeting.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add webvtt-py dependency and create services module</name>
  <files>pyproject.toml, src/services/__init__.py</files>
  <action>
1. Run `uv add webvtt-py` to add the VTT/SRT parsing library.

2. Create `src/services/__init__.py` as empty file (module marker).

3. Verify webvtt-py is installed: `uv pip list | grep webvtt`
  </action>
  <verify>`uv pip list | grep webvtt-py` shows version 0.5.x installed</verify>
  <done>webvtt-py dependency added, src/services/ module created</done>
</task>

<task type="auto">
  <name>Task 2: Create TranscriptParser service</name>
  <files>src/services/transcript_parser.py</files>
  <action>
Create `src/services/transcript_parser.py` with:

1. Imports:
   ```python
   from dataclasses import dataclass
   from io import StringIO
   import webvtt
   from src.models.meeting import Utterance
   ```

2. Define `ParsedTranscript` dataclass:
   ```python
   @dataclass
   class ParsedTranscript:
       utterances: list[Utterance]
       speakers: list[str]
       duration_seconds: float | None
   ```

3. Define `TranscriptParser` class:
   - Class constant: `SUPPORTED_FORMATS = {".vtt", ".srt"}`

   - Method `parse(self, content: str, format: str) -> ParsedTranscript`:
     - Validate format is in SUPPORTED_FORMATS (raise ValueError if not)
     - Parse based on format:
       - VTT: `captions = webvtt.from_string(content)`
       - SRT: `captions = webvtt.from_srt(StringIO(content))`
     - Iterate captions:
       - Extract speaker from `caption.voice` or default to "Unknown Speaker"
       - Create Utterance with speaker, text=caption.text, start_time=caption.start_in_seconds, end_time=caption.end_in_seconds
       - Track unique speakers in a set
     - Calculate duration: Use last caption's end_in_seconds if captions exist
     - Return ParsedTranscript with utterances, sorted speakers list, duration

4. Handle edge cases:
   - Empty content: Return empty utterances list, empty speakers list, None duration
   - No voice tags: All utterances get "Unknown Speaker"
   - Malformed content: Let webvtt-py raise exception (caller handles)
  </action>
  <verify>
Run quick inline test:
```python
uv run python -c "
from src.services.transcript_parser import TranscriptParser, ParsedTranscript

parser = TranscriptParser()

# Test VTT with voice tags
vtt = '''WEBVTT

00:00:01.000 --> 00:00:05.000
<v John>Hello everyone

00:00:05.000 --> 00:00:10.000
<v Jane>Hi John
'''

result = parser.parse(vtt, '.vtt')
assert len(result.utterances) == 2
assert result.speakers == ['Jane', 'John']
assert result.utterances[0].speaker == 'John'
assert result.utterances[0].start_time == 1.0
assert result.utterances[1].end_time == 10.0
print('VTT parsing: PASS')

# Test SRT without voice tags
srt = '''1
00:00:01,000 --> 00:00:05,000
Hello everyone

2
00:00:05,000 --> 00:00:10,000
Hi there
'''

result2 = parser.parse(srt, '.srt')
assert len(result2.utterances) == 2
assert result2.speakers == ['Unknown Speaker']
print('SRT parsing: PASS')

print('All parser tests passed!')
"
```
  </verify>
  <done>
- TranscriptParser class created with parse() method
- Handles both VTT and SRT formats
- Extracts speakers from voice tags (VTT) or defaults to "Unknown Speaker"
- Returns ParsedTranscript with utterances, speakers, duration
  </done>
</task>

<task type="auto">
  <name>Task 3: Add parser unit tests</name>
  <files>tests/test_transcript_parser.py</files>
  <action>
Create `tests/test_transcript_parser.py` with pytest tests:

1. Test VTT with voice tags:
   - Parse valid VTT content with multiple speakers
   - Assert correct utterance count
   - Assert speakers list contains all unique speakers
   - Assert timestamps are floats in seconds

2. Test SRT without voice tags:
   - Parse valid SRT content
   - Assert all utterances have "Unknown Speaker"

3. Test empty content:
   - Parse empty VTT (just "WEBVTT\n\n")
   - Assert empty utterances list

4. Test invalid format:
   - Call parse with unsupported format (e.g., ".txt")
   - Assert ValueError is raised

5. Test malformed content:
   - Pass garbage content
   - Assert exception is raised (webvtt.errors.MalformedFileError or similar)

6. Test duration calculation:
   - Parse content with known end time
   - Assert duration_seconds matches last caption's end time

Use fixtures for common test data.
  </action>
  <verify>`uv run pytest tests/test_transcript_parser.py -v` all tests pass</verify>
  <done>
- Unit tests cover VTT parsing with voice tags
- Unit tests cover SRT parsing
- Unit tests cover edge cases (empty, invalid format, malformed)
- All tests pass
  </done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/test_transcript_parser.py -v` - all parser tests pass
2. `uv run pytest` - all existing tests still pass
3. Manual verification: Parser extracts speakers from voice tags correctly
</verification>

<success_criteria>
- webvtt-py dependency added
- TranscriptParser class parses VTT and SRT formats
- Speaker names extracted from voice tags (or "Unknown Speaker" default)
- Timestamps converted to float seconds
- Duration calculated from last caption
- Unit tests cover happy path and edge cases
</success_criteria>

<output>
After completion, create `.planning/phases/02-transcript-ingestion/02-02-SUMMARY.md`
</output>
