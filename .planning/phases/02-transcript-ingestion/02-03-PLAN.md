---
phase: 02-transcript-ingestion
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/api/meetings.py
  - tests/test_meetings_api.py
autonomous: true

must_haves:
  truths:
    - "Upload endpoint creates Meeting from parsed transcript"
    - "MeetingCreated event is published with meeting details"
    - "TranscriptParsed event is published with parsing stats"
    - "Response includes meeting ID, title, speaker count, utterance count"
    - "Meeting is persisted via event store"
  artifacts:
    - path: "src/api/meetings.py"
      provides: "Complete upload endpoint with parsing and events"
      exports: ["router", "MeetingResponse"]
    - path: "tests/test_meetings_api.py"
      provides: "Integration tests for upload endpoint"
      min_lines: 40
  key_links:
    - from: "src/api/meetings.py"
      to: "src/services/transcript_parser.py"
      via: "import and call parse()"
      pattern: "from src\\.services\\.transcript_parser import"
    - from: "src/api/meetings.py"
      to: "src/events/types.py"
      via: "import MeetingCreated, TranscriptParsed"
      pattern: "from src\\.events\\.types import MeetingCreated"
    - from: "src/api/meetings.py"
      to: "src/events/bus.py"
      via: "event_bus.publish_and_store()"
      pattern: "event_bus\\.publish_and_store"
---

<objective>
Wire the upload endpoint to the parser and event system to complete the transcript ingestion flow.

Purpose: This plan integrates the upload endpoint (02-01) with the parser (02-02) and the existing event infrastructure to satisfy all Phase 2 success criteria. After this plan, uploading a transcript creates a persisted Meeting with events.

Output: Complete transcript ingestion pipeline: Upload -> Parse -> Create Meeting -> Emit Events -> Persist
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-transcript-ingestion/02-RESEARCH.md

# Phase 2 plan summaries (created by prior plans)
@.planning/phases/02-transcript-ingestion/02-01-SUMMARY.md
@.planning/phases/02-transcript-ingestion/02-02-SUMMARY.md

# Existing infrastructure
@src/models/meeting.py
@src/events/types.py
@src/events/bus.py
@src/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update upload endpoint with parsing and event emission</name>
  <files>src/api/meetings.py</files>
  <action>
Update `src/api/meetings.py` to integrate parser and events:

1. Add imports:
   ```python
   from datetime import datetime, UTC
   from pathlib import Path
   from fastapi import Depends, Request
   from pydantic import BaseModel

   from src.models.meeting import Meeting
   from src.services.transcript_parser import TranscriptParser
   from src.events.bus import EventBus
   from src.events.types import MeetingCreated, TranscriptParsed
   ```

2. Add MeetingResponse model:
   ```python
   class MeetingResponse(BaseModel):
       id: str
       title: str
       date: datetime
       speaker_count: int
       utterance_count: int
       duration_seconds: float | None
   ```

3. Add EventBus dependency:
   ```python
   def get_event_bus(request: Request) -> EventBus:
       return request.app.state.event_bus
   ```

4. Update the upload endpoint signature:
   ```python
   @router.post("/upload", response_model=MeetingResponse)
   async def upload_transcript(
       file: UploadFile,
       event_bus: EventBus = Depends(get_event_bus),
   ) -> MeetingResponse:
   ```

5. After validation passes, add parsing:
   ```python
   parser = TranscriptParser()
   try:
       parsed = parser.parse(content, ext)
   except Exception as e:
       raise HTTPException(status_code=400, detail=f"Failed to parse transcript: {str(e)}")
   ```

6. Create Meeting:
   ```python
   meeting = Meeting(
       title=Path(file.filename).stem.replace("_", " ").replace("-", " "),
       date=datetime.now(UTC),
       utterances=parsed.utterances,
       duration_minutes=int(parsed.duration_seconds / 60) if parsed.duration_seconds else None,
       transcript_source="zoom",
       transcript_file=file.filename,
   )
   ```

7. Emit and persist events:
   ```python
   await event_bus.publish_and_store(MeetingCreated(
       aggregate_id=meeting.id,
       title=meeting.title,
       meeting_date=meeting.date,
       participant_count=len(parsed.speakers),
       transcript_filename=file.filename,
   ))

   await event_bus.publish_and_store(TranscriptParsed(
       aggregate_id=meeting.id,
       utterance_count=len(parsed.utterances),
       speaker_count=len(parsed.speakers),
       duration_seconds=parsed.duration_seconds,
   ))
   ```

8. Return MeetingResponse:
   ```python
   return MeetingResponse(
       id=str(meeting.id),
       title=meeting.title,
       date=meeting.date,
       speaker_count=len(parsed.speakers),
       utterance_count=len(parsed.utterances),
       duration_seconds=parsed.duration_seconds,
   )
   ```
  </action>
  <verify>
Start server and test with real VTT:
```bash
cd /Users/gabrielguenette/projects/tpm-admin-agent

# Create test VTT with speakers
cat > /tmp/meeting.vtt << 'EOF'
WEBVTT

00:00:01.000 --> 00:00:05.000
<v Alice>Let's start the meeting

00:00:05.000 --> 00:00:10.000
<v Bob>Sounds good, I have an update

00:00:10.000 --> 00:00:15.000
<v Alice>Go ahead Bob
EOF

# Start server in background
uv run python -m src.main &
sleep 3

# Test upload
curl -X POST -F "file=@/tmp/meeting.vtt" http://localhost:8000/meetings/upload | python -m json.tool

# Kill server
pkill -f "python -m src.main"
```

Expected response should include:
- id: UUID string
- title: "meeting"
- speaker_count: 2
- utterance_count: 3
- duration_seconds: ~15.0
  </verify>
  <done>
- Upload endpoint parses transcript using TranscriptParser
- Meeting object created from parsed data
- Events emitted and persisted via EventBus
- Response includes meeting ID and statistics
  </done>
</task>

<task type="auto">
  <name>Task 2: Add integration tests for upload endpoint</name>
  <files>tests/test_meetings_api.py</files>
  <action>
Create `tests/test_meetings_api.py` with pytest tests using FastAPI TestClient:

1. Setup:
   ```python
   import pytest
   from fastapi.testclient import TestClient
   from io import BytesIO

   from src.main import app

   @pytest.fixture
   def client():
       with TestClient(app) as c:
           yield c
   ```

2. Test successful VTT upload:
   - Create valid VTT content with voice tags
   - POST to /meetings/upload with file
   - Assert 200 status
   - Assert response has id, title, speaker_count, utterance_count
   - Assert speaker_count matches unique speakers in VTT

3. Test successful SRT upload:
   - Create valid SRT content (no voice tags)
   - POST to /meetings/upload
   - Assert 200 status
   - Assert speaker_count is 1 (Unknown Speaker)

4. Test invalid extension:
   - POST file with .txt extension
   - Assert 415 status
   - Assert error detail mentions unsupported file type

5. Test empty file:
   - POST empty .vtt file
   - Assert 400 status

6. Test malformed VTT:
   - POST .vtt file with garbage content
   - Assert 400 status
   - Assert error detail mentions parse failure

Use BytesIO to create in-memory file uploads for TestClient.
  </action>
  <verify>`uv run pytest tests/test_meetings_api.py -v` all tests pass</verify>
  <done>
- Integration tests verify end-to-end upload flow
- Tests cover success cases (VTT, SRT)
- Tests cover error cases (invalid extension, empty, malformed)
- All tests pass
  </done>
</task>

</tasks>

<verification>
1. `uv run pytest` - all tests pass (parser + API)
2. Manual test: Upload VTT file, verify response includes meeting ID
3. Manual test: Check events are persisted by querying event store
4. All Phase 2 success criteria verified:
   - [x] User can upload VTT or SRT transcript file via API endpoint
   - [x] System parses transcript into timestamped utterances
   - [x] System identifies distinct speakers from transcript
   - [x] Parsed transcript persists as Meeting event in event store
</verification>

<success_criteria>
- Upload endpoint integrates parser and creates Meeting
- MeetingCreated and TranscriptParsed events emitted and persisted
- Response includes meeting ID, speaker count, utterance count, duration
- Integration tests cover happy path and error cases
- All Phase 2 requirements (ING-01, ING-02, ING-03) satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/02-transcript-ingestion/02-03-SUMMARY.md`
</output>
