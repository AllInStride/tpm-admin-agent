---
phase: 09-communication-automation
plan: 04
type: execute
wave: 3
depends_on: ["09-02", "09-03"]
files_modified:
  - src/communication/service.py
  - src/communication/__init__.py
  - src/api/communication.py
  - src/api/router.py
  - src/main.py
  - tests/communication/test_service.py
  - tests/api/test_communication_api.py
autonomous: true

must_haves:
  truths:
    - "CommunicationService orchestrates all four artifact types"
    - "API endpoints expose all four generation capabilities"
    - "Service logs generation requests for audit"
    - "Endpoints return both markdown and plain text"
  artifacts:
    - path: "src/communication/service.py"
      provides: "CommunicationService orchestrator"
      exports: ["CommunicationService", "GenerationResult"]
    - path: "src/api/communication.py"
      provides: "REST endpoints for communication generation"
      exports: ["router"]
  key_links:
    - from: "src/communication/service.py"
      to: "src/communication/generators/"
      via: "Generator instances"
      pattern: "ExecStatusGenerator|TeamStatusGenerator|EscalationGenerator|TalkingPointsGenerator"
    - from: "src/api/communication.py"
      to: "src/communication/service.py"
      via: "FastAPI dependency injection"
      pattern: "Depends.*get_communication_service"
    - from: "src/api/router.py"
      to: "src/api/communication.py"
      via: "Router inclusion"
      pattern: "include_router.*communication"
---

<objective>
Create CommunicationService to orchestrate all generators, and expose REST API endpoints for generating exec status, team status, escalation emails, and talking points.

Purpose: Ties together all generators into a single service interface with API access.
Output: Complete communication automation system with API endpoints ready for use.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-communication-automation/09-CONTEXT.md
@.planning/phases/09-communication-automation/09-RESEARCH.md
@.planning/phases/09-communication-automation/09-01-SUMMARY.md
@.planning/phases/09-communication-automation/09-02-SUMMARY.md
@.planning/phases/09-communication-automation/09-03-SUMMARY.md

# All generators and infrastructure
@src/communication/schemas.py
@src/communication/data_aggregator.py
@src/communication/generators/exec_status.py
@src/communication/generators/team_status.py
@src/communication/generators/escalation.py
@src/communication/generators/talking_points.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: CommunicationService orchestrator</name>
  <files>
    src/communication/service.py
    src/communication/__init__.py
    tests/communication/test_service.py
  </files>
  <action>
**service.py:**
```python
from dataclasses import dataclass
from datetime import datetime
from typing import Literal

import structlog

from src.communication.data_aggregator import DataAggregator, StatusData
from src.communication.generators.exec_status import ExecStatusGenerator
from src.communication.generators.team_status import TeamStatusGenerator
from src.communication.generators.escalation import EscalationGenerator
from src.communication.generators.talking_points import TalkingPointsGenerator
from src.communication.schemas import GeneratedArtifact, EscalationRequest
from src.services.llm_client import LLMClient

logger = structlog.get_logger()

ArtifactType = Literal['exec_status', 'team_status', 'escalation', 'talking_points']


@dataclass
class GenerationResult:
    """Result of artifact generation."""
    artifact_type: ArtifactType
    artifact: GeneratedArtifact
    data_used: StatusData | None
    generated_at: datetime


class CommunicationService:
    """Orchestrates communication artifact generation."""

    def __init__(
        self,
        llm_client: LLMClient,
        data_aggregator: DataAggregator,
    ):
        self._llm = llm_client
        self._aggregator = data_aggregator

        # Initialize generators
        self._exec_status = ExecStatusGenerator(llm_client)
        self._team_status = TeamStatusGenerator(llm_client)
        self._escalation = EscalationGenerator(llm_client)
        self._talking_points = TalkingPointsGenerator(llm_client)

    async def generate_exec_status(
        self,
        project_id: str,
        since: datetime,
        until: datetime | None = None,
    ) -> GenerationResult:
        """Generate executive status update (COM-01)."""
        logger.info("generating exec status", project_id=project_id, since=since.isoformat())

        data = await self._aggregator.gather_for_status(project_id, since, until)
        artifact = await self._exec_status.generate(data)

        logger.info("exec status generated", project_id=project_id, rag=artifact.metadata.get('rag_overall'))

        return GenerationResult(
            artifact_type='exec_status',
            artifact=artifact,
            data_used=data,
            generated_at=datetime.now(),
        )

    async def generate_team_status(
        self,
        project_id: str,
        since: datetime,
        until: datetime | None = None,
    ) -> GenerationResult:
        """Generate team status update (COM-02)."""
        data = await self._aggregator.gather_for_status(project_id, since, until)
        artifact = await self._team_status.generate(data)

        return GenerationResult(
            artifact_type='team_status',
            artifact=artifact,
            data_used=data,
            generated_at=datetime.now(),
        )

    async def generate_escalation(
        self,
        request: EscalationRequest,
    ) -> GenerationResult:
        """Generate escalation email (COM-03)."""
        artifact = await self._escalation.generate(request)

        return GenerationResult(
            artifact_type='escalation',
            artifact=artifact,
            data_used=None,
            generated_at=datetime.now(),
        )

    async def generate_talking_points(
        self,
        project_id: str,
        meeting_type: str = "exec_review",
        since: datetime | None = None,
    ) -> GenerationResult:
        """Generate exec talking points (COM-04)."""
        # Default to 30 days ago if no since provided
        if since is None:
            since = datetime.now() - timedelta(days=30)

        data = await self._aggregator.gather_for_status(project_id, since)
        artifact = await self._talking_points.generate(data, meeting_type=meeting_type)

        return GenerationResult(
            artifact_type='talking_points',
            artifact=artifact,
            data_used=data,
            generated_at=datetime.now(),
        )
```

Update `__init__.py` to export CommunicationService, GenerationResult, and all generator classes.

Create tests for service orchestration with mocked generators.
  </action>
  <verify>
`uv run pytest tests/communication/test_service.py -v` passes
  </verify>
  <done>
CommunicationService orchestrates all four generators and returns GenerationResult with artifact and metadata
  </done>
</task>

<task type="auto">
  <name>Task 2: API endpoints and app integration</name>
  <files>
    src/api/communication.py
    src/api/router.py
    src/main.py
    tests/api/test_communication_api.py
  </files>
  <action>
**src/api/communication.py:**
```python
from datetime import datetime
from typing import Annotated

from fastapi import APIRouter, Depends
from pydantic import BaseModel, Field

from src.communication.service import CommunicationService, GenerationResult
from src.communication.schemas import EscalationRequest

router = APIRouter(prefix="/communication", tags=["communication"])


class StatusRequest(BaseModel):
    """Request for status generation."""
    project_id: str = Field(description="Project ID to report on")
    since: datetime = Field(description="Start of reporting period")
    until: datetime | None = Field(default=None, description="End of period (default: now)")


class TalkingPointsRequest(BaseModel):
    """Request for talking points generation."""
    project_id: str
    meeting_type: str = Field(default="exec_review")
    since: datetime | None = None


class GenerationResponse(BaseModel):
    """Response from generation endpoint."""
    artifact_type: str
    markdown: str
    plain_text: str
    generated_at: datetime
    metadata: dict


def get_communication_service() -> CommunicationService:
    """Dependency to get CommunicationService instance."""
    from src.main import get_app_state
    return get_app_state().communication_service


@router.post("/exec-status", response_model=GenerationResponse)
async def generate_exec_status(
    request: StatusRequest,
    service: Annotated[CommunicationService, Depends(get_communication_service)],
) -> GenerationResponse:
    """Generate executive status update (COM-01)."""
    result = await service.generate_exec_status(
        project_id=request.project_id,
        since=request.since,
        until=request.until,
    )
    return _to_response(result)


@router.post("/team-status", response_model=GenerationResponse)
async def generate_team_status(
    request: StatusRequest,
    service: Annotated[CommunicationService, Depends(get_communication_service)],
) -> GenerationResponse:
    """Generate team status update (COM-02)."""
    result = await service.generate_team_status(
        project_id=request.project_id,
        since=request.since,
        until=request.until,
    )
    return _to_response(result)


@router.post("/escalation", response_model=GenerationResponse)
async def generate_escalation(
    request: EscalationRequest,
    service: Annotated[CommunicationService, Depends(get_communication_service)],
) -> GenerationResponse:
    """Generate escalation email (COM-03)."""
    result = await service.generate_escalation(request)
    return _to_response(result)


@router.post("/talking-points", response_model=GenerationResponse)
async def generate_talking_points(
    request: TalkingPointsRequest,
    service: Annotated[CommunicationService, Depends(get_communication_service)],
) -> GenerationResponse:
    """Generate exec talking points (COM-04)."""
    result = await service.generate_talking_points(
        project_id=request.project_id,
        meeting_type=request.meeting_type,
        since=request.since,
    )
    return _to_response(result)


def _to_response(result: GenerationResult) -> GenerationResponse:
    """Convert GenerationResult to API response."""
    return GenerationResponse(
        artifact_type=result.artifact_type,
        markdown=result.artifact.markdown,
        plain_text=result.artifact.plain_text,
        generated_at=result.generated_at,
        metadata=result.artifact.metadata,
    )
```

**Update src/api/router.py:**
Add `from src.api.communication import router as communication_router` and include it.

**Update src/main.py:**
- Add CommunicationService initialization in app state (similar to PrepService pattern)
- Create CommunicationService with LLMClient and DataAggregator
- DataAggregator gets OpenItemsRepository and ProjectionRepository

Create API tests verifying:
- All four endpoints accept correct request bodies
- Responses contain markdown and plain_text
- Metadata is included
  </action>
  <verify>
`uv run pytest tests/api/test_communication_api.py -v` passes and `uv run pytest` shows all tests passing
  </verify>
  <done>
API endpoints expose all four generation capabilities, integrated into main.py with proper dependency injection
  </done>
</task>

</tasks>

<verification>
- [ ] `src/communication/service.py` exists with CommunicationService
- [ ] `src/api/communication.py` exists with four endpoints
- [ ] Communication router included in main router
- [ ] CommunicationService initialized in main.py
- [ ] `uv run pytest` shows all tests passing
- [ ] `curl -X POST http://localhost:8000/communication/exec-status -H "Content-Type: application/json" -d '{"project_id":"test","since":"2025-01-01T00:00:00Z"}'` returns response (with ANTHROPIC_API_KEY set)
</verification>

<success_criteria>
- CommunicationService orchestrates all four artifact types
- Four API endpoints: POST /communication/exec-status, /team-status, /escalation, /talking-points
- Endpoints return GenerationResponse with markdown, plain_text, and metadata
- All tests pass including existing 663+ tests
- Phase 9 requirements COM-01 through COM-04 complete
</success_criteria>

<output>
After completion, create `.planning/phases/09-communication-automation/09-04-SUMMARY.md`
</output>
