---
phase: 06-system-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/adapters/slack_adapter.py
  - src/integration/notification_service.py
  - src/integration/schemas.py
  - src/integration/__init__.py
  - tests/integration/test_notification_service.py
autonomous: true

must_haves:
  truths:
    - "SlackAdapter can send DMs to users by email"
    - "NotificationService sends item assignment notifications"
    - "Notifications include item title, due date, and Smartsheet link"
    - "All notifications are logged in audit trail"
  artifacts:
    - path: "src/adapters/slack_adapter.py"
      provides: "Extended SlackAdapter with send_dm"
      exports: ["SlackAdapter"]
    - path: "src/integration/notification_service.py"
      provides: "NotificationService class"
      exports: ["NotificationService", "NotificationResult", "NotificationRecord"]
  key_links:
    - from: "src/integration/notification_service.py"
      to: "src/adapters/slack_adapter.py"
      via: "SlackAdapter.send_dm"
      pattern: "slack\\.send_dm"
    - from: "src/adapters/slack_adapter.py"
      to: "chat.postMessage"
      via: "Slack API"
      pattern: "chat_postMessage"
---

<objective>
Extend SlackAdapter with DM capability and create NotificationService for owner notifications.

Purpose: Notify action item owners when they are assigned tasks from meeting extraction.
Output: send_dm method on SlackAdapter, NotificationService with audit trail.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-system-integration/06-CONTEXT.md
@.planning/phases/06-system-integration/06-RESEARCH.md
@src/adapters/slack_adapter.py
@src/output/schemas.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend SlackAdapter with send_dm method</name>
  <files>
    - src/adapters/slack_adapter.py
  </files>
  <action>
1. Add `send_dm` method to SlackAdapter:

```python
async def send_dm(
    self,
    user_id: str,
    message: str,
) -> dict:
    """Send direct message to a Slack user.

    Args:
        user_id: Slack user ID (not email)
        message: Message text (supports mrkdwn formatting)

    Returns:
        Dict with 'success' and 'ts' (timestamp) or 'error'
    """
    try:
        client = self._get_client()
        response = client.chat_postMessage(
            channel=user_id,  # DM channel opened automatically
            text=message,
        )
        return {"success": True, "ts": response["ts"]}
    except SlackApiError as e:
        error = e.response.get("error", "unknown_error")
        logger.warning(
            "Failed to send Slack DM",
            user_id=user_id,
            error=error,
        )
        return {"success": False, "error": error}
```

2. Add `lookup_user_by_email` method (returns full user info, not just bool):

```python
async def lookup_user_by_email(self, email: str) -> dict | None:
    """Look up Slack user by email address.

    Args:
        email: Email address to look up

    Returns:
        User dict with 'id', 'name', 'profile' or None if not found
    """
    try:
        client = self._get_client()
        result = client.users_lookupByEmail(email=email)
        return result.get("user")
    except SlackApiError as e:
        if e.response.get("error") == "users_not_found":
            return None
        logger.warning(
            "Slack API error looking up user",
            email=email,
            error=str(e),
        )
        return None
```

3. Update existing `verify_member` to use new `lookup_user_by_email` internally
  </action>
  <verify>`uv run python -c "from src.adapters import SlackAdapter; s = SlackAdapter('test'); print(hasattr(s, 'send_dm'))"` prints True</verify>
  <done>SlackAdapter has send_dm and lookup_user_by_email methods</done>
</task>

<task type="auto">
  <name>Task 2: Create NotificationService with audit trail</name>
  <files>
    - src/integration/notification_service.py
    - src/integration/schemas.py
    - src/integration/__init__.py
  </files>
  <action>
1. Add notification schemas to `src/integration/schemas.py`:

```python
class NotificationResult(BaseModel):
    """Result of a notification attempt."""
    success: bool
    recipient_email: str
    recipient_slack_id: str | None = None
    message_ts: str | None = None
    error: str | None = None

class NotificationRecord(BaseModel):
    """Audit record for a sent notification."""
    recipient_email: str
    item_description: str
    item_type: str
    smartsheet_url: str | None
    sent_at: datetime
    success: bool
    error: str | None = None
```

2. Create `src/integration/notification_service.py`:

```python
class NotificationService:
    """Service for sending and auditing RAID item notifications."""

    def __init__(self, slack_adapter: SlackAdapter):
        self._slack = slack_adapter
        self._audit_log: list[NotificationRecord] = []

    async def notify_owner(
        self,
        owner_email: str,
        item: ActionItemData,
        smartsheet_url: str | None = None,
    ) -> NotificationResult:
        """Notify owner of new action item assignment.

        Looks up user by email, sends DM, records in audit log.
        """
        # Lookup user by email
        user = await self._slack.lookup_user_by_email(owner_email)
        if not user:
            result = NotificationResult(
                success=False,
                recipient_email=owner_email,
                error="user_not_found",
            )
            self._record_audit(owner_email, item, smartsheet_url, result)
            return result

        # Format and send message
        message = self._format_message(item, smartsheet_url)
        dm_result = await self._slack.send_dm(user["id"], message)

        result = NotificationResult(
            success=dm_result.get("success", False),
            recipient_email=owner_email,
            recipient_slack_id=user["id"],
            message_ts=dm_result.get("ts"),
            error=dm_result.get("error"),
        )
        self._record_audit(owner_email, item, smartsheet_url, result)
        return result

    def _format_message(
        self,
        item: ActionItemData,
        smartsheet_url: str | None,
    ) -> str:
        """Format notification message per CONTEXT.md spec.

        Plain text with mrkdwn: title, due date, Smartsheet link.
        """
        parts = [
            "*New action item assigned to you:*",
            f"> {item.description}",
        ]
        if item.due_date:
            parts.append(f"*Due:* {item.due_date}")
        if smartsheet_url:
            parts.append(f"<{smartsheet_url}|View in Smartsheet>")
        return "\n".join(parts)

    def _record_audit(
        self,
        email: str,
        item: ActionItemData,
        url: str | None,
        result: NotificationResult,
    ) -> None:
        """Record notification in audit log."""
        record = NotificationRecord(
            recipient_email=email,
            item_description=item.description,
            item_type="Action",
            smartsheet_url=url,
            sent_at=datetime.now(UTC),
            success=result.success,
            error=result.error,
        )
        self._audit_log.append(record)
        logger.info(
            "notification recorded",
            email=email,
            success=result.success,
        )

    def get_audit_log(self) -> list[NotificationRecord]:
        """Return copy of audit log."""
        return list(self._audit_log)

    def clear_audit_log(self) -> None:
        """Clear audit log."""
        self._audit_log.clear()
```

3. Update `src/integration/__init__.py` to export NotificationService, NotificationResult, NotificationRecord
  </action>
  <verify>`uv run python -c "from src.integration import NotificationService; print('OK')"` succeeds</verify>
  <done>NotificationService created with notify_owner, message formatting, and audit log</done>
</task>

<task type="auto">
  <name>Task 3: Add NotificationService tests</name>
  <files>
    - tests/integration/__init__.py
    - tests/integration/test_notification_service.py
  </files>
  <action>
1. Create `tests/integration/__init__.py`

2. Create `tests/integration/test_notification_service.py` with:

Test fixtures:
- `mock_slack_adapter`: Mock SlackAdapter with lookup_user_by_email and send_dm
- `notification_service`: NotificationService with mocked adapter
- `sample_action_item`: ActionItemData for testing

Test cases:
- `test_notify_owner_success`: User found, DM sent, audit recorded
- `test_notify_owner_user_not_found`: User lookup returns None, error recorded
- `test_notify_owner_dm_fails`: User found but DM fails, error recorded
- `test_format_message_with_due_date`: Message includes due date
- `test_format_message_without_due_date`: Message omits due date line
- `test_format_message_with_smartsheet_url`: Message includes link
- `test_format_message_without_url`: Message omits link
- `test_audit_log_populated`: Verify audit log has correct entries
- `test_audit_log_cleared`: Verify clear_audit_log works
- `test_get_audit_log_returns_copy`: Verify returns copy, not reference

3. Mock strategy:
   - Mock SlackAdapter.lookup_user_by_email to return user dict or None
   - Mock SlackAdapter.send_dm to return success/failure dict
   - No actual Slack API calls

4. Run: `uv run pytest tests/integration/test_notification_service.py -v`
  </action>
  <verify>`uv run pytest tests/integration/test_notification_service.py -v` - all tests pass</verify>
  <done>NotificationService has comprehensive test coverage</done>
</task>

</tasks>

<verification>
1. `uv run python -c "from src.adapters import SlackAdapter; print('send_dm' in dir(SlackAdapter))"` - True
2. `uv run python -c "from src.integration import NotificationService"` - imports
3. `uv run pytest tests/integration/test_notification_service.py -v` - tests pass
4. `uv run pytest tests/adapters/test_slack_adapter.py -v` - existing + new tests pass
5. `uv run pytest` - full suite passes
</verification>

<success_criteria>
- SlackAdapter has send_dm and lookup_user_by_email methods
- NotificationService sends DMs for action item assignments
- Message format: title, due date, Smartsheet link (per CONTEXT.md)
- All notifications recorded in audit log
- Tests verify success, failure, and edge cases
</success_criteria>

<output>
After completion, create `.planning/phases/06-system-integration/06-02-SUMMARY.md`
</output>
