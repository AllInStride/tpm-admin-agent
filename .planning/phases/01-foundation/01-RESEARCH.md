# Phase 1: Foundation - Research

**Researched:** 2026-01-17
**Domain:** Python project scaffolding, event infrastructure, canonical data models
**Confidence:** HIGH

## Summary

Phase 1 Foundation establishes the architectural bedrock for the TPM Admin Agent. Research focused on five areas: FastAPI project structure, Pydantic v2 patterns for canonical models, in-process event bus implementation, Turso/libSQL Python client setup, and uv project initialization.

The standard approach for 2025 FastAPI projects is domain-based organization (not file-type grouping), using async-first patterns, and Pydantic v2 for validation. For event infrastructure, a simple in-memory pub/sub system (like PyPubSub or a custom implementation) suffices for Phase 1 - no need for Redis/Kafka complexity yet. The event store should use append-only SQLite tables in Turso with optimistic concurrency control. uv replaces pip+venv entirely, providing 10-100x faster dependency resolution.

**Primary recommendation:** Start with `uv init`, domain-based folder structure under `src/`, Pydantic v2 BaseModel with `@field_validator` decorators, and a simple async event bus using Python's built-in asyncio patterns.

## Standard Stack

The established libraries/tools for this domain.

### Core

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| uv | Latest | Package manager | 10-100x faster than pip, replaces pip+venv+pyenv, Rust-based |
| Python | 3.12+ | Runtime | LangGraph requires 3.10+, FastAPI dropped 3.8 support |
| FastAPI | 0.128+ | API framework | Async-first, Pydantic-native, automatic OpenAPI docs |
| Pydantic | 2.12+ | Data validation | Rust-powered core, native structured outputs support |
| uvicorn | Latest | ASGI server | Standard FastAPI server, supports --reload for dev |

### Supporting

| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| python-dotenv | Latest | Environment variables | Load .env files in development |
| structlog | 25.0+ | Structured logging | Better OpenTelemetry integration than Loguru |
| pytest | 8.0+ | Testing | Industry standard test framework |
| pytest-asyncio | 1.3.0+ | Async test support | Required for testing async FastAPI routes |
| ruff | Latest | Linting/formatting | Replaces black+flake8+isort, extremely fast |
| mypy | Latest | Type checking | Static type analysis |
| pre-commit | Latest | Git hooks | Run linting/tests before commits |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| PyPubSub | Custom async event bus | PyPubSub is sync-only; custom gives async control |
| eventsourcing lib | Custom event store | Library is heavy; simple SQLite table suffices for v1 |
| SQLAlchemy | Raw libsql | ORM adds complexity; direct SQL is clearer for event store |

**Installation:**
```bash
# Initialize project
uv init tpm-admin-agent
cd tpm-admin-agent

# Add production dependencies
uv add fastapi uvicorn pydantic python-dotenv structlog

# Add Turso/libSQL client
uv add libsql

# Add development dependencies
uv add --dev pytest pytest-asyncio ruff mypy pre-commit httpx
```

## Architecture Patterns

### Recommended Project Structure

Domain-based organization (not file-type) scales better for monoliths with multiple modules.

```
tpm-admin-agent/
├── pyproject.toml          # Project config, dependencies
├── uv.lock                  # Lockfile (auto-generated)
├── .python-version          # Python version (auto-generated by uv)
├── .pre-commit-config.yaml  # Pre-commit hooks
├── .env                     # Local secrets (gitignored)
├── .env.example             # Template for .env
├── src/
│   ├── __init__.py
│   ├── main.py              # FastAPI app entry point
│   ├── config.py            # Global settings (pydantic-settings)
│   ├── models/              # Canonical data models (Pydantic)
│   │   ├── __init__.py
│   │   ├── base.py          # BaseModel config
│   │   ├── meeting.py       # Meeting, Transcript
│   │   ├── action_item.py   # ActionItem, ActionItemStatus
│   │   ├── decision.py      # Decision
│   │   ├── risk.py          # Risk
│   │   ├── issue.py         # Issue
│   │   └── participant.py   # Participant
│   ├── events/              # Event infrastructure
│   │   ├── __init__.py
│   │   ├── base.py          # Base Event class
│   │   ├── types.py         # Typed event definitions
│   │   ├── bus.py           # Event bus implementation
│   │   └── store.py         # Event store (append-only)
│   ├── db/                  # Database layer
│   │   ├── __init__.py
│   │   └── turso.py         # Turso client wrapper
│   └── api/                 # API routes
│       ├── __init__.py
│       ├── health.py        # Health check endpoints
│       └── router.py        # API router aggregation
├── tests/
│   ├── __init__.py
│   ├── conftest.py          # pytest fixtures
│   ├── test_models.py       # Model validation tests
│   ├── test_events.py       # Event bus tests
│   └── test_api.py          # API endpoint tests
└── scripts/
    └── init_db.py           # Database initialization
```

### Pattern 1: Pydantic v2 BaseModel with Validators

**What:** Define canonical data models using Pydantic v2 BaseModel with field validators and model validators for complex validation logic.

**When to use:** All domain entities (Meeting, ActionItem, Decision, Risk, Issue, Participant).

**Example:**
```python
# Source: https://docs.pydantic.dev/latest/concepts/models/
from datetime import datetime
from typing import Optional
from uuid import UUID, uuid4
from enum import Enum
from pydantic import BaseModel, Field, field_validator, model_validator, ConfigDict

class ActionItemStatus(str, Enum):
    OPEN = "open"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    CANCELLED = "cancelled"

class BaseEntity(BaseModel):
    """Base class for all domain entities."""
    model_config = ConfigDict(
        frozen=False,  # Allow mutation
        str_strip_whitespace=True,  # Auto-strip strings
        validate_default=True,  # Validate default values
    )

    id: UUID = Field(default_factory=uuid4)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class ActionItem(BaseEntity):
    """An action item extracted from a meeting."""
    meeting_id: UUID
    description: str = Field(min_length=1, max_length=1000)
    assignee_id: Optional[UUID] = None
    due_date: Optional[datetime] = None
    status: ActionItemStatus = ActionItemStatus.OPEN
    source_text: Optional[str] = None  # Original transcript text

    @field_validator('description')
    @classmethod
    def description_not_empty(cls, v: str) -> str:
        if not v.strip():
            raise ValueError('Description cannot be empty or whitespace')
        return v.strip()

    @model_validator(mode='after')
    def due_date_in_future(self) -> 'ActionItem':
        if self.due_date and self.due_date < datetime.utcnow():
            # Allow past due dates but log warning
            pass  # Could emit event here
        return self
```

### Pattern 2: Async Event Bus (In-Process)

**What:** Simple pub/sub event bus using Python asyncio. Publishers emit typed events, subscribers receive events matching their subscriptions.

**When to use:** Decoupling components within the same process. Replace with Redis/Kafka only when scaling to multiple processes.

**Example:**
```python
# Source: Custom implementation based on asyncio patterns
from typing import Callable, Dict, List, Type, TypeVar
from dataclasses import dataclass, field
from datetime import datetime
from uuid import UUID, uuid4
import asyncio

T = TypeVar('T', bound='Event')

@dataclass
class Event:
    """Base class for all events."""
    event_id: UUID = field(default_factory=uuid4)
    timestamp: datetime = field(default_factory=datetime.utcnow)

    @property
    def event_type(self) -> str:
        return self.__class__.__name__

@dataclass
class ActionItemExtracted(Event):
    """Emitted when an action item is extracted from a transcript."""
    meeting_id: UUID
    action_item_id: UUID
    description: str
    assignee_name: Optional[str] = None

class EventBus:
    """Simple async event bus for in-process pub/sub."""

    def __init__(self):
        self._subscribers: Dict[Type[Event], List[Callable]] = {}
        self._lock = asyncio.Lock()

    def subscribe(self, event_type: Type[T], handler: Callable[[T], None]) -> None:
        """Subscribe a handler to an event type."""
        if event_type not in self._subscribers:
            self._subscribers[event_type] = []
        self._subscribers[event_type].append(handler)

    async def publish(self, event: Event) -> None:
        """Publish an event to all subscribers."""
        event_type = type(event)
        handlers = self._subscribers.get(event_type, [])

        # Run handlers concurrently
        tasks = []
        for handler in handlers:
            if asyncio.iscoroutinefunction(handler):
                tasks.append(handler(event))
            else:
                # Wrap sync handlers
                tasks.append(asyncio.to_thread(handler, event))

        if tasks:
            await asyncio.gather(*tasks, return_exceptions=True)

# Usage
bus = EventBus()

async def on_action_item(event: ActionItemExtracted):
    print(f"New action item: {event.description}")

bus.subscribe(ActionItemExtracted, on_action_item)
await bus.publish(ActionItemExtracted(
    meeting_id=uuid4(),
    action_item_id=uuid4(),
    description="Review the design doc"
))
```

### Pattern 3: Append-Only Event Store with Turso

**What:** Persist all events in an append-only table. Never update or delete. Use optimistic concurrency with version/sequence numbers.

**When to use:** Storing domain events for audit trail, replay capability, and building projections.

**Example:**
```python
# Source: Based on event sourcing patterns and Turso docs
import libsql_client
import json
from dataclasses import asdict
from typing import AsyncIterator, Optional

class EventStore:
    """Append-only event store using Turso/libSQL."""

    def __init__(self, client: libsql_client.Client):
        self.client = client

    async def init_schema(self) -> None:
        """Create the events table if it doesn't exist."""
        await self.client.execute("""
            CREATE TABLE IF NOT EXISTS events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                event_id TEXT UNIQUE NOT NULL,
                event_type TEXT NOT NULL,
                aggregate_id TEXT,
                aggregate_type TEXT,
                event_data TEXT NOT NULL,
                timestamp TEXT NOT NULL,
                version INTEGER,
                created_at TEXT DEFAULT CURRENT_TIMESTAMP
            )
        """)
        await self.client.execute("""
            CREATE INDEX IF NOT EXISTS idx_events_aggregate
            ON events(aggregate_type, aggregate_id, version)
        """)
        await self.client.execute("""
            CREATE INDEX IF NOT EXISTS idx_events_type
            ON events(event_type)
        """)

    async def append(
        self,
        event: Event,
        aggregate_id: Optional[str] = None,
        aggregate_type: Optional[str] = None,
        expected_version: Optional[int] = None
    ) -> None:
        """Append an event to the store."""
        event_data = json.dumps(asdict(event), default=str)

        # Get next version for aggregate if using optimistic concurrency
        version = None
        if aggregate_id and expected_version is not None:
            result = await self.client.execute(
                "SELECT MAX(version) FROM events WHERE aggregate_id = ?",
                [aggregate_id]
            )
            current_version = result.rows[0][0] or 0
            if current_version != expected_version:
                raise ConcurrencyError(
                    f"Expected version {expected_version}, got {current_version}"
                )
            version = current_version + 1

        await self.client.execute(
            """INSERT INTO events
               (event_id, event_type, aggregate_id, aggregate_type,
                event_data, timestamp, version)
               VALUES (?, ?, ?, ?, ?, ?, ?)""",
            [
                str(event.event_id),
                event.event_type,
                aggregate_id,
                aggregate_type,
                event_data,
                event.timestamp.isoformat(),
                version
            ]
        )

    async def get_events(
        self,
        aggregate_id: str,
        from_version: int = 0
    ) -> AsyncIterator[dict]:
        """Retrieve events for an aggregate, optionally from a version."""
        result = await self.client.execute(
            """SELECT event_type, event_data, version, timestamp
               FROM events
               WHERE aggregate_id = ? AND version > ?
               ORDER BY version ASC""",
            [aggregate_id, from_version]
        )
        for row in result.rows:
            yield {
                "event_type": row[0],
                "data": json.loads(row[1]),
                "version": row[2],
                "timestamp": row[3]
            }

class ConcurrencyError(Exception):
    """Raised when optimistic concurrency check fails."""
    pass
```

### Pattern 4: FastAPI Health Check Endpoints

**What:** Expose `/health`, `/health/live`, and `/health/ready` endpoints for monitoring and orchestration systems.

**When to use:** Always. Required for Fly.io deployment, useful for local development.

**Example:**
```python
# Source: https://www.index.dev/blog/how-to-implement-health-check-in-python
from fastapi import APIRouter, Depends
from pydantic import BaseModel
from datetime import datetime

router = APIRouter(prefix="/health", tags=["health"])

class HealthResponse(BaseModel):
    status: str
    timestamp: datetime
    version: str

class ReadinessResponse(BaseModel):
    status: str
    checks: dict

@router.get("/", response_model=HealthResponse)
async def health_check():
    """Basic health check."""
    return HealthResponse(
        status="healthy",
        timestamp=datetime.utcnow(),
        version="0.1.0"
    )

@router.get("/live")
async def liveness():
    """Kubernetes liveness probe. App is running."""
    return {"status": "alive"}

@router.get("/ready")
async def readiness(db_healthy: bool = Depends(check_database)):
    """Kubernetes readiness probe. App can serve traffic."""
    checks = {
        "database": "ok" if db_healthy else "failed"
    }
    status = "ready" if all(v == "ok" for v in checks.values()) else "not_ready"
    return ReadinessResponse(status=status, checks=checks)

async def check_database() -> bool:
    """Check database connectivity."""
    try:
        # Ping database
        return True
    except Exception:
        return False
```

### Anti-Patterns to Avoid

- **File-type organization:** Don't put all models in `/models`, all routers in `/routers`. Use domain-based organization instead.
- **Sync event handlers:** Use async handlers in the event bus to avoid blocking the event loop.
- **Mutable event store:** Never UPDATE or DELETE events. Append-only is fundamental.
- **Direct database access in routes:** Use dependency injection and repository pattern.
- **Missing type hints:** Pydantic v2 requires type hints. Use them everywhere.

## Don't Hand-Roll

Problems that look simple but have existing solutions.

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Environment variables | Custom config loader | python-dotenv + pydantic-settings | Handles type coercion, validation, .env files |
| UUID generation | Custom ID scheme | Python's uuid4() | Universally unique, no collision handling needed |
| JSON serialization | Custom datetime handling | Pydantic model_dump_json() | Handles all types, configurable |
| Date/time parsing | String manipulation | datetime + Pydantic validators | Timezone aware, ISO format handling |
| Linting/formatting | Multiple tools | ruff | Single tool replaces black+flake8+isort |

**Key insight:** Pydantic v2 handles most serialization edge cases. Trust it for data validation and transformation.

## Common Pitfalls

### Pitfall 1: Blocking Async Event Loop

**What goes wrong:** Using synchronous database calls or blocking operations in async routes.

**Why it happens:** Mixing sync libraries (like the sync libsql client) with async FastAPI routes.

**How to avoid:** Use `asyncio.to_thread()` for sync operations, or use async-native libraries.

**Warning signs:** Slow response times under concurrent load, timeout errors.

### Pitfall 2: Missing Pydantic v2 Migration Changes

**What goes wrong:** Using Pydantic v1 patterns (`.dict()`, `@validator`, `class Config`).

**Why it happens:** Outdated tutorials, muscle memory from v1.

**How to avoid:** Use v2 patterns: `.model_dump()`, `@field_validator`, `model_config = ConfigDict(...)`.

**Warning signs:** Deprecation warnings, TypeErrors on model instantiation.

### Pitfall 3: Event Store Without Indexes

**What goes wrong:** Slow event replay as event count grows.

**Why it happens:** Forgetting to index aggregate_id, event_type columns.

**How to avoid:** Create indexes during schema initialization (see event store example).

**Warning signs:** Query times increasing linearly with event count.

### Pitfall 4: Forgetting uv.lock in Git

**What goes wrong:** Different developers get different dependency versions.

**Why it happens:** Treating uv.lock like a generated file that shouldn't be committed.

**How to avoid:** Always commit uv.lock. It ensures reproducible builds.

**Warning signs:** "Works on my machine" issues, CI failures.

### Pitfall 5: Turso WebSocket Driver Deprecation

**What goes wrong:** Connection failures to Turso after June 2025.

**Why it happens:** Using old `libsql-client` package instead of new `libsql` package.

**How to avoid:** Use `pip install libsql` (or `uv add libsql`), not `libsql-client`.

**Warning signs:** WebSocket connection errors to Turso cloud.

## Code Examples

Verified patterns from official sources.

### uv Project Initialization

```bash
# Source: https://docs.astral.sh/uv/guides/projects/

# Create new project
uv init tpm-admin-agent
cd tpm-admin-agent

# Add dependencies
uv add fastapi uvicorn pydantic

# Add dev dependencies (goes to [dependency-groups] dev)
uv add --dev pytest ruff mypy

# Run the application
uv run uvicorn src.main:app --reload

# Run tests
uv run pytest
```

### pyproject.toml Structure

```toml
# Source: https://docs.astral.sh/uv/guides/projects/
[project]
name = "tpm-admin-agent"
version = "0.1.0"
description = "TPM Admin Agent - Meeting intelligence automation"
readme = "README.md"
requires-python = ">=3.12"
dependencies = [
    "fastapi>=0.128,<0.130",
    "uvicorn>=0.30",
    "pydantic>=2.12,<3.0",
    "python-dotenv>=1.0",
    "structlog>=25.0",
    "libsql>=0.1",
]

[dependency-groups]
dev = [
    "pytest>=8.0",
    "pytest-asyncio>=1.3",
    "ruff>=0.8",
    "mypy>=1.10",
    "pre-commit>=4.0",
    "httpx>=0.28",
]

[tool.uv]
dev-dependencies = ["pytest", "ruff", "mypy", "pre-commit"]

[tool.ruff]
line-length = 88
target-version = "py312"

[tool.ruff.lint]
select = ["E", "F", "I", "N", "W", "UP"]

[tool.pytest.ini_options]
asyncio_mode = "auto"
testpaths = ["tests"]

[tool.mypy]
python_version = "3.12"
strict = true
```

### FastAPI Main Application

```python
# Source: https://fastapi.tiangolo.com/tutorial/bigger-applications/
# src/main.py
from fastapi import FastAPI
from contextlib import asynccontextmanager
import libsql_client
from src.api.health import router as health_router
from src.config import settings

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Startup and shutdown logic."""
    # Startup: Initialize database connection
    app.state.db = libsql_client.create_client(
        url=settings.turso_database_url,
        auth_token=settings.turso_auth_token
    )
    yield
    # Shutdown: Close connections
    await app.state.db.close()

app = FastAPI(
    title="TPM Admin Agent",
    description="Meeting intelligence automation for TPMs",
    version="0.1.0",
    lifespan=lifespan
)

app.include_router(health_router)

if __name__ == "__main__":
    import uvicorn
    uvicorn.run("src.main:app", host="0.0.0.0", port=8000, reload=True)
```

### Turso/libSQL Async Client

```python
# Source: https://docs.turso.tech/sdk/python/quickstart
# src/db/turso.py
import libsql_client
from typing import Any, List, Optional

class TursoClient:
    """Wrapper for Turso/libSQL async client."""

    def __init__(self, url: str, auth_token: Optional[str] = None):
        self.url = url
        self.auth_token = auth_token
        self._client: Optional[libsql_client.Client] = None

    async def connect(self) -> None:
        """Establish database connection."""
        if self.auth_token:
            self._client = libsql_client.create_client(
                url=self.url,
                auth_token=self.auth_token
            )
        else:
            # Local file database
            self._client = libsql_client.create_client(url=self.url)

    async def execute(self, sql: str, params: List[Any] = None) -> Any:
        """Execute a SQL statement."""
        if not self._client:
            raise RuntimeError("Not connected. Call connect() first.")
        return await self._client.execute(sql, params or [])

    async def close(self) -> None:
        """Close the database connection."""
        if self._client:
            await self._client.close()
            self._client = None
```

### Pre-Commit Configuration

```yaml
# Source: https://pre-commit.com/ and https://medium.com/@fistralpro/pytest-pre-commit-hook-b492edd0560e
# .pre-commit-config.yaml
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.8.0
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format

  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.10.0
    hooks:
      - id: mypy
        additional_dependencies: [pydantic>=2.0]

  - repo: local
    hooks:
      - id: pytest
        name: pytest
        entry: uv run pytest tests -x --tb=short
        language: system
        types: [python]
        pass_filenames: false
        always_run: true
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| pip + venv | uv | 2024 | 10-100x faster, unified tooling |
| Pydantic v1 `.dict()` | Pydantic v2 `.model_dump()` | 2023 | Rust core, better performance |
| `@validator` | `@field_validator` | Pydantic v2 | Different signature, mode parameter |
| `class Config:` | `model_config = ConfigDict()` | Pydantic v2 | Dict-based config |
| black + flake8 + isort | ruff | 2023-2024 | Single tool, much faster |
| libsql-client | libsql | June 2025 | Old package deprecated |
| requirements.txt | pyproject.toml | 2022+ | PEP 621 standard |

**Deprecated/outdated:**
- `libsql-client` package: Use `libsql` instead
- Pydantic v1 patterns: Migrate to v2 API
- pip for project management: Use uv for speed and lockfile support

## Open Questions

Things that couldn't be fully resolved.

1. **libsql async API completeness**
   - What we know: `libsql_client.create_client()` provides async context manager
   - What's unclear: Whether the new `libsql` package has equivalent async support
   - Recommendation: Start with `libsql_client` for async, verify `libsql` package capabilities

2. **Event bus scaling threshold**
   - What we know: In-memory event bus works for single-process
   - What's unclear: At what point Redis pub/sub becomes necessary
   - Recommendation: Start in-memory, instrument with metrics, migrate when needed

3. **Turso connection pooling**
   - What we know: Single client per app works for low concurrency
   - What's unclear: Connection pooling strategy for high concurrency
   - Recommendation: Use single client initially, profile under load

## Sources

### Primary (HIGH confidence)
- [uv Documentation - Working on Projects](https://docs.astral.sh/uv/guides/projects/) - Project initialization, dependencies
- [uv Documentation - Managing Dependencies](https://docs.astral.sh/uv/concepts/projects/dependencies/) - Dev dependencies, groups
- [Pydantic Documentation - Models](https://docs.pydantic.dev/latest/concepts/models/) - BaseModel, model_config
- [Pydantic Documentation - Validators](https://docs.pydantic.dev/latest/concepts/validators/) - field_validator, model_validator
- [Pydantic Documentation - Fields](https://docs.pydantic.dev/latest/concepts/fields/) - Field constraints, aliases
- [FastAPI Documentation - Bigger Applications](https://fastapi.tiangolo.com/tutorial/bigger-applications/) - Router organization
- [Turso Python SDK Quickstart](https://docs.turso.tech/sdk/python/quickstart) - libsql client usage

### Secondary (MEDIUM confidence)
- [FastAPI Best Practices GitHub](https://github.com/zhanymkanov/fastapi-best-practices) - Domain-based structure, patterns
- [libsql-client-py GitHub](https://github.com/tursodatabase/libsql-client-py) - Async client API
- [PyPubSub Documentation](https://pypubsub.readthedocs.io/) - Pub/sub patterns (sync only)
- [FastAPI Health Check Patterns](https://www.index.dev/blog/how-to-implement-health-check-in-python) - Health endpoints

### Tertiary (LOW confidence)
- WebSearch results for event sourcing SQLite patterns - Needs verification with actual implementation
- WebSearch results for pytest pre-commit hooks - Multiple approaches exist

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Verified via official docs (uv, FastAPI, Pydantic, Turso)
- Architecture: HIGH - Domain-based structure from FastAPI best practices repo
- Pitfalls: MEDIUM - Some based on WebSearch, needs validation during implementation

**Research date:** 2026-01-17
**Valid until:** 2026-02-17 (30 days - stack is stable)
