---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/models/__init__.py
  - src/models/base.py
  - src/models/meeting.py
  - src/models/participant.py
  - src/models/action_item.py
  - src/models/decision.py
  - src/models/risk.py
  - src/models/issue.py
  - tests/test_models.py
autonomous: true

must_haves:
  truths:
    - "All six canonical models can be instantiated with valid data"
    - "Models reject invalid data with clear validation errors"
    - "Models serialize to JSON and deserialize correctly"
    - "All model tests pass"
  artifacts:
    - path: "src/models/base.py"
      provides: "BaseEntity with id, created_at, updated_at"
      contains: "class BaseEntity"
    - path: "src/models/meeting.py"
      provides: "Meeting model with title, date, participants, transcript"
      contains: "class Meeting"
    - path: "src/models/participant.py"
      provides: "Participant model with name, email, role"
      contains: "class Participant"
    - path: "src/models/action_item.py"
      provides: "ActionItem model with description, assignee, due_date, status"
      contains: "class ActionItem"
    - path: "src/models/decision.py"
      provides: "Decision model with description, context, rationale"
      contains: "class Decision"
    - path: "src/models/risk.py"
      provides: "Risk model with description, severity, mitigation"
      contains: "class Risk"
    - path: "src/models/issue.py"
      provides: "Issue model with description, status, priority"
      contains: "class Issue"
    - path: "tests/test_models.py"
      provides: "Model validation tests"
      min_lines: 100
  key_links:
    - from: "src/models/action_item.py"
      to: "src/models/base.py"
      via: "inheritance"
      pattern: "class ActionItem\\(BaseEntity\\)"
    - from: "src/models/meeting.py"
      to: "src/models/participant.py"
      via: "composition"
      pattern: "list\\[Participant\\]"
---

<objective>
Define canonical data models for all RAID entities using Pydantic v2.

Purpose: Establish the type-safe data layer that all subsequent phases will use for meetings, participants, and extracted artifacts (Actions, Decisions, Risks, Issues).

Output: Six validated Pydantic models (Meeting, Participant, ActionItem, Decision, Risk, Issue) with comprehensive tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create base entity and participant models</name>
  <files>
    src/models/__init__.py
    src/models/base.py
    src/models/participant.py
  </files>
  <action>
1. Create models directory:
   ```bash
   mkdir -p src/models
   ```

2. Create src/models/base.py with BaseEntity:
   ```python
   """Base entity class for all domain models."""

   from datetime import datetime, timezone
   from typing import Optional
   from uuid import UUID, uuid4

   from pydantic import BaseModel, ConfigDict, Field


   class BaseEntity(BaseModel):
       """Base class for all domain entities.

       Provides:
       - Unique ID (UUID)
       - Created/updated timestamps
       - Standard serialization config
       """

       model_config = ConfigDict(
           str_strip_whitespace=True,
           validate_default=True,
           from_attributes=True,
       )

       id: UUID = Field(default_factory=uuid4, description="Unique entity identifier")
       created_at: datetime = Field(
           default_factory=lambda: datetime.now(timezone.utc),
           description="When entity was created",
       )
       updated_at: datetime = Field(
           default_factory=lambda: datetime.now(timezone.utc),
           description="When entity was last updated",
       )

       def touch(self) -> None:
           """Update the updated_at timestamp."""
           self.updated_at = datetime.now(timezone.utc)
   ```

3. Create src/models/participant.py:
   ```python
   """Participant model for meeting attendees."""

   from enum import Enum
   from typing import Optional
   from uuid import UUID

   from pydantic import EmailStr, Field, field_validator

   from src.models.base import BaseEntity


   class ParticipantRole(str, Enum):
       """Role of participant in the meeting."""

       HOST = "host"
       PRESENTER = "presenter"
       ATTENDEE = "attendee"
       GUEST = "guest"


   class Participant(BaseEntity):
       """A person who participated in a meeting.

       Participants are identified from:
       - Zoom meeting metadata (calendar invite)
       - Transcript speaker diarization
       - Manual roster mapping
       """

       name: str = Field(
           min_length=1,
           max_length=200,
           description="Display name (from transcript or roster)",
       )
       email: Optional[EmailStr] = Field(
           default=None,
           description="Email address (if resolved from roster)",
       )
       role: ParticipantRole = Field(
           default=ParticipantRole.ATTENDEE,
           description="Role in the meeting",
       )
       external_id: Optional[str] = Field(
           default=None,
           description="ID in external system (Slack, Google, etc.)",
       )
       transcript_name: Optional[str] = Field(
           default=None,
           description="Original name as it appeared in transcript",
       )
       confidence: float = Field(
           default=1.0,
           ge=0.0,
           le=1.0,
           description="Confidence score for identity resolution (0-1)",
       )

       @field_validator("name")
       @classmethod
       def name_not_empty(cls, v: str) -> str:
           """Ensure name is not just whitespace."""
           if not v.strip():
               raise ValueError("Name cannot be empty or whitespace")
           return v.strip()
   ```

4. Create src/models/__init__.py to export models:
   ```python
   """Canonical data models for TPM Admin Agent.

   These models define the core entities:
   - Meeting: A recorded meeting with transcript
   - Participant: A person who attended a meeting
   - ActionItem: A task extracted from a meeting
   - Decision: A decision made during a meeting
   - Risk: A risk identified during a meeting
   - Issue: An issue raised during a meeting
   """

   from src.models.base import BaseEntity
   from src.models.participant import Participant, ParticipantRole

   __all__ = [
       "BaseEntity",
       "Participant",
       "ParticipantRole",
   ]
   ```
  </action>
  <verify>
    Run: `uv run python -c "from src.models import Participant, ParticipantRole; p = Participant(name='John'); print(p.model_dump_json())"`
    Expected: JSON output with id, name, created_at, updated_at, role, etc.
  </verify>
  <done>
    BaseEntity and Participant models created with validation, can be instantiated and serialized.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Meeting and RAID models</name>
  <files>
    src/models/meeting.py
    src/models/action_item.py
    src/models/decision.py
    src/models/risk.py
    src/models/issue.py
    src/models/__init__.py
  </files>
  <action>
1. Create src/models/meeting.py:
   ```python
   """Meeting model for recorded meetings with transcripts."""

   from datetime import datetime
   from typing import Optional
   from uuid import UUID

   from pydantic import Field, field_validator

   from src.models.base import BaseEntity
   from src.models.participant import Participant


   class Utterance(BaseEntity):
       """A single utterance (speech segment) in a transcript."""

       speaker_name: str = Field(description="Name of the speaker")
       speaker_id: Optional[UUID] = Field(
           default=None, description="Resolved participant ID"
       )
       text: str = Field(min_length=1, description="What was said")
       start_time: float = Field(ge=0, description="Start time in seconds")
       end_time: float = Field(ge=0, description="End time in seconds")

       @field_validator("text")
       @classmethod
       def text_not_empty(cls, v: str) -> str:
           """Ensure text is not just whitespace."""
           if not v.strip():
               raise ValueError("Utterance text cannot be empty")
           return v.strip()


   class TranscriptSource(BaseEntity):
       """Source information for a transcript file."""

       filename: str = Field(description="Original filename")
       format: str = Field(description="File format (vtt, srt)")
       upload_time: datetime = Field(description="When transcript was uploaded")
       raw_content: Optional[str] = Field(
           default=None, description="Original file content"
       )


   class Meeting(BaseEntity):
       """A recorded meeting with transcript and extracted data.

       Meetings are the primary aggregate root. They contain:
       - Basic meeting info (title, date, duration)
       - Participants (resolved from transcript)
       - Transcript (parsed utterances)
       - Extracted items (actions, decisions, risks, issues) - referenced by ID
       """

       title: str = Field(
           min_length=1, max_length=500, description="Meeting title or subject"
       )
       meeting_date: datetime = Field(description="When the meeting occurred")
       duration_minutes: Optional[int] = Field(
           default=None, ge=0, description="Meeting duration in minutes"
       )
       participants: list[Participant] = Field(
           default_factory=list, description="People who attended"
       )
       utterances: list[Utterance] = Field(
           default_factory=list, description="Parsed transcript utterances"
       )
       transcript_source: Optional[TranscriptSource] = Field(
           default=None, description="Original transcript file info"
       )

       # References to extracted items (populated during extraction)
       action_item_ids: list[UUID] = Field(
           default_factory=list, description="IDs of extracted action items"
       )
       decision_ids: list[UUID] = Field(
           default_factory=list, description="IDs of extracted decisions"
       )
       risk_ids: list[UUID] = Field(
           default_factory=list, description="IDs of extracted risks"
       )
       issue_ids: list[UUID] = Field(
           default_factory=list, description="IDs of extracted issues"
       )

       # Metadata
       external_meeting_id: Optional[str] = Field(
           default=None, description="ID from Zoom or other source"
       )
       recording_url: Optional[str] = Field(
           default=None, description="URL to meeting recording"
       )

       @field_validator("title")
       @classmethod
       def title_not_empty(cls, v: str) -> str:
           """Ensure title is not just whitespace."""
           if not v.strip():
               raise ValueError("Meeting title cannot be empty")
           return v.strip()
   ```

2. Create src/models/action_item.py:
   ```python
   """ActionItem model for tasks extracted from meetings."""

   from datetime import datetime
   from enum import Enum
   from typing import Optional
   from uuid import UUID

   from pydantic import Field, field_validator

   from src.models.base import BaseEntity


   class ActionItemStatus(str, Enum):
       """Status of an action item."""

       OPEN = "open"
       IN_PROGRESS = "in_progress"
       COMPLETED = "completed"
       CANCELLED = "cancelled"
       BLOCKED = "blocked"


   class ActionItemPriority(str, Enum):
       """Priority level for an action item."""

       LOW = "low"
       MEDIUM = "medium"
       HIGH = "high"
       CRITICAL = "critical"


   class ActionItem(BaseEntity):
       """An action item extracted from a meeting transcript.

       Action items represent tasks that need to be completed.
       They are extracted by the AI agent and linked to:
       - The source meeting
       - An assignee (if mentioned)
       - A due date (if stated)
       """

       meeting_id: UUID = Field(description="ID of source meeting")
       description: str = Field(
           min_length=1, max_length=2000, description="What needs to be done"
       )
       assignee_id: Optional[UUID] = Field(
           default=None, description="ID of assigned participant"
       )
       assignee_name: Optional[str] = Field(
           default=None, description="Name mentioned in transcript"
       )
       due_date: Optional[datetime] = Field(
           default=None, description="When this is due (if stated)"
       )
       status: ActionItemStatus = Field(
           default=ActionItemStatus.OPEN, description="Current status"
       )
       priority: ActionItemPriority = Field(
           default=ActionItemPriority.MEDIUM, description="Priority level"
       )

       # Extraction metadata
       source_text: Optional[str] = Field(
           default=None, description="Original transcript text that mentioned this"
       )
       confidence: float = Field(
           default=1.0,
           ge=0.0,
           le=1.0,
           description="Extraction confidence score (0-1)",
       )
       extraction_notes: Optional[str] = Field(
           default=None, description="Notes from extraction process"
       )

       # External system tracking
       external_id: Optional[str] = Field(
           default=None, description="ID in external system (Smartsheet, Jira)"
       )
       external_url: Optional[str] = Field(
           default=None, description="Link to external system"
       )

       @field_validator("description")
       @classmethod
       def description_not_empty(cls, v: str) -> str:
           """Ensure description is not just whitespace."""
           if not v.strip():
               raise ValueError("Action item description cannot be empty")
           return v.strip()
   ```

3. Create src/models/decision.py:
   ```python
   """Decision model for decisions extracted from meetings."""

   from typing import Optional
   from uuid import UUID

   from pydantic import Field, field_validator

   from src.models.base import BaseEntity


   class Decision(BaseEntity):
       """A decision made during a meeting.

       Decisions capture:
       - What was decided
       - Why (context and rationale)
       - Who was involved
       """

       meeting_id: UUID = Field(description="ID of source meeting")
       description: str = Field(
           min_length=1, max_length=2000, description="What was decided"
       )
       context: Optional[str] = Field(
           default=None, description="Background context for the decision"
       )
       rationale: Optional[str] = Field(
           default=None, description="Why this decision was made"
       )
       alternatives_considered: list[str] = Field(
           default_factory=list, description="Other options that were discussed"
       )
       stakeholder_ids: list[UUID] = Field(
           default_factory=list, description="IDs of people involved in decision"
       )

       # Extraction metadata
       source_text: Optional[str] = Field(
           default=None, description="Original transcript text"
       )
       confidence: float = Field(
           default=1.0,
           ge=0.0,
           le=1.0,
           description="Extraction confidence score (0-1)",
       )

       # External tracking
       external_id: Optional[str] = Field(
           default=None, description="ID in external system"
       )

       @field_validator("description")
       @classmethod
       def description_not_empty(cls, v: str) -> str:
           """Ensure description is not just whitespace."""
           if not v.strip():
               raise ValueError("Decision description cannot be empty")
           return v.strip()
   ```

4. Create src/models/risk.py:
   ```python
   """Risk model for risks identified in meetings."""

   from enum import Enum
   from typing import Optional
   from uuid import UUID

   from pydantic import Field, field_validator

   from src.models.base import BaseEntity


   class RiskSeverity(str, Enum):
       """Severity level of a risk."""

       LOW = "low"
       MEDIUM = "medium"
       HIGH = "high"
       CRITICAL = "critical"


   class RiskStatus(str, Enum):
       """Current status of a risk."""

       IDENTIFIED = "identified"
       ANALYZING = "analyzing"
       MITIGATING = "mitigating"
       MONITORING = "monitoring"
       RESOLVED = "resolved"
       ACCEPTED = "accepted"


   class Risk(BaseEntity):
       """A risk identified during a meeting.

       Risks capture potential problems:
       - What could go wrong
       - How severe it would be
       - Potential mitigation strategies
       """

       meeting_id: UUID = Field(description="ID of source meeting")
       description: str = Field(
           min_length=1, max_length=2000, description="What the risk is"
       )
       severity: RiskSeverity = Field(
           default=RiskSeverity.MEDIUM, description="How severe if it occurs"
       )
       status: RiskStatus = Field(
           default=RiskStatus.IDENTIFIED, description="Current risk status"
       )
       likelihood: Optional[str] = Field(
           default=None, description="Likelihood assessment"
       )
       impact: Optional[str] = Field(
           default=None, description="Impact if risk materializes"
       )
       mitigation: Optional[str] = Field(
           default=None, description="Proposed mitigation strategy"
       )
       owner_id: Optional[UUID] = Field(
           default=None, description="ID of risk owner"
       )
       owner_name: Optional[str] = Field(
           default=None, description="Name of risk owner"
       )

       # Extraction metadata
       source_text: Optional[str] = Field(
           default=None, description="Original transcript text"
       )
       confidence: float = Field(
           default=1.0,
           ge=0.0,
           le=1.0,
           description="Extraction confidence score (0-1)",
       )

       # External tracking
       external_id: Optional[str] = Field(
           default=None, description="ID in external system"
       )

       @field_validator("description")
       @classmethod
       def description_not_empty(cls, v: str) -> str:
           """Ensure description is not just whitespace."""
           if not v.strip():
               raise ValueError("Risk description cannot be empty")
           return v.strip()
   ```

5. Create src/models/issue.py:
   ```python
   """Issue model for issues raised in meetings."""

   from enum import Enum
   from typing import Optional
   from uuid import UUID

   from pydantic import Field, field_validator

   from src.models.base import BaseEntity


   class IssuePriority(str, Enum):
       """Priority of an issue."""

       LOW = "low"
       MEDIUM = "medium"
       HIGH = "high"
       CRITICAL = "critical"


   class IssueStatus(str, Enum):
       """Status of an issue."""

       OPEN = "open"
       IN_PROGRESS = "in_progress"
       BLOCKED = "blocked"
       RESOLVED = "resolved"
       CLOSED = "closed"
       WONT_FIX = "wont_fix"


   class Issue(BaseEntity):
       """An issue raised during a meeting.

       Issues are current problems (vs risks which are potential problems):
       - What's happening now
       - Who's affected
       - What's the resolution path
       """

       meeting_id: UUID = Field(description="ID of source meeting")
       description: str = Field(
           min_length=1, max_length=2000, description="What the issue is"
       )
       priority: IssuePriority = Field(
           default=IssuePriority.MEDIUM, description="Issue priority"
       )
       status: IssueStatus = Field(
           default=IssueStatus.OPEN, description="Current status"
       )
       impact: Optional[str] = Field(
           default=None, description="Who/what is affected"
       )
       resolution: Optional[str] = Field(
           default=None, description="How it was/will be resolved"
       )
       owner_id: Optional[UUID] = Field(
           default=None, description="ID of issue owner"
       )
       owner_name: Optional[str] = Field(
           default=None, description="Name of issue owner"
       )
       related_action_ids: list[UUID] = Field(
           default_factory=list, description="Action items created to address this"
       )

       # Extraction metadata
       source_text: Optional[str] = Field(
           default=None, description="Original transcript text"
       )
       confidence: float = Field(
           default=1.0,
           ge=0.0,
           le=1.0,
           description="Extraction confidence score (0-1)",
       )

       # External tracking
       external_id: Optional[str] = Field(
           default=None, description="ID in external system"
       )

       @field_validator("description")
       @classmethod
       def description_not_empty(cls, v: str) -> str:
           """Ensure description is not just whitespace."""
           if not v.strip():
               raise ValueError("Issue description cannot be empty")
           return v.strip()
   ```

6. Update src/models/__init__.py to export all models:
   ```python
   """Canonical data models for TPM Admin Agent.

   These models define the core entities:
   - Meeting: A recorded meeting with transcript
   - Participant: A person who attended a meeting
   - ActionItem: A task extracted from a meeting
   - Decision: A decision made during a meeting
   - Risk: A risk identified during a meeting
   - Issue: An issue raised during a meeting
   """

   from src.models.action_item import ActionItem, ActionItemPriority, ActionItemStatus
   from src.models.base import BaseEntity
   from src.models.decision import Decision
   from src.models.issue import Issue, IssuePriority, IssueStatus
   from src.models.meeting import Meeting, TranscriptSource, Utterance
   from src.models.participant import Participant, ParticipantRole
   from src.models.risk import Risk, RiskSeverity, RiskStatus

   __all__ = [
       # Base
       "BaseEntity",
       # Meeting
       "Meeting",
       "Utterance",
       "TranscriptSource",
       # Participant
       "Participant",
       "ParticipantRole",
       # RAID
       "ActionItem",
       "ActionItemStatus",
       "ActionItemPriority",
       "Decision",
       "Risk",
       "RiskSeverity",
       "RiskStatus",
       "Issue",
       "IssuePriority",
       "IssueStatus",
   ]
   ```
  </action>
  <verify>
    Run: `uv run python -c "from src.models import Meeting, ActionItem, Decision, Risk, Issue; from uuid import uuid4; from datetime import datetime, timezone; m = Meeting(title='Test', meeting_date=datetime.now(timezone.utc)); print('Meeting:', m.id); a = ActionItem(meeting_id=m.id, description='Do thing'); print('Action:', a.id)"`
    Expected: Prints Meeting and ActionItem UUIDs without errors.
  </verify>
  <done>
    All five RAID models created (Meeting, ActionItem, Decision, Risk, Issue) with proper validation and relationships.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive model tests</name>
  <files>
    tests/test_models.py
  </files>
  <action>
1. Create tests/test_models.py with comprehensive tests:
   ```python
   """Tests for canonical data models."""

   from datetime import datetime, timezone
   from uuid import uuid4

   import pytest

   from src.models import (
       ActionItem,
       ActionItemPriority,
       ActionItemStatus,
       BaseEntity,
       Decision,
       Issue,
       IssuePriority,
       IssueStatus,
       Meeting,
       Participant,
       ParticipantRole,
       Risk,
       RiskSeverity,
       RiskStatus,
       Utterance,
   )


   class TestBaseEntity:
       """Tests for BaseEntity."""

       def test_creates_with_defaults(self) -> None:
           """BaseEntity generates id and timestamps."""

           class TestEntity(BaseEntity):
               name: str

           entity = TestEntity(name="test")
           assert entity.id is not None
           assert entity.created_at is not None
           assert entity.updated_at is not None

       def test_touch_updates_timestamp(self) -> None:
           """touch() updates the updated_at timestamp."""

           class TestEntity(BaseEntity):
               name: str

           entity = TestEntity(name="test")
           original = entity.updated_at
           entity.touch()
           assert entity.updated_at >= original


   class TestParticipant:
       """Tests for Participant model."""

       def test_creates_with_name(self) -> None:
           """Participant can be created with just a name."""
           p = Participant(name="John Doe")
           assert p.name == "John Doe"
           assert p.role == ParticipantRole.ATTENDEE
           assert p.confidence == 1.0

       def test_creates_with_all_fields(self) -> None:
           """Participant accepts all optional fields."""
           p = Participant(
               name="Jane Smith",
               email="jane@example.com",
               role=ParticipantRole.HOST,
               external_id="U12345",
               transcript_name="Jane S",
               confidence=0.85,
           )
           assert p.email == "jane@example.com"
           assert p.role == ParticipantRole.HOST
           assert p.external_id == "U12345"
           assert p.confidence == 0.85

       def test_rejects_empty_name(self) -> None:
           """Participant requires non-empty name."""
           with pytest.raises(ValueError, match="Name cannot be empty"):
               Participant(name="   ")

       def test_strips_whitespace(self) -> None:
           """Participant strips whitespace from name."""
           p = Participant(name="  John Doe  ")
           assert p.name == "John Doe"

       def test_rejects_invalid_email(self) -> None:
           """Participant rejects invalid email format."""
           with pytest.raises(ValueError):
               Participant(name="John", email="not-an-email")

       def test_confidence_bounds(self) -> None:
           """Confidence must be between 0 and 1."""
           with pytest.raises(ValueError):
               Participant(name="John", confidence=1.5)
           with pytest.raises(ValueError):
               Participant(name="John", confidence=-0.1)


   class TestMeeting:
       """Tests for Meeting model."""

       def test_creates_with_required_fields(self) -> None:
           """Meeting can be created with title and date."""
           m = Meeting(
               title="Weekly Standup",
               meeting_date=datetime.now(timezone.utc),
           )
           assert m.title == "Weekly Standup"
           assert m.participants == []
           assert m.utterances == []

       def test_creates_with_participants(self) -> None:
           """Meeting can include participants."""
           p = Participant(name="John")
           m = Meeting(
               title="Team Meeting",
               meeting_date=datetime.now(timezone.utc),
               participants=[p],
           )
           assert len(m.participants) == 1
           assert m.participants[0].name == "John"

       def test_creates_with_utterances(self) -> None:
           """Meeting can include utterances."""
           u = Utterance(
               speaker_name="John",
               text="Hello everyone",
               start_time=0.0,
               end_time=2.5,
           )
           m = Meeting(
               title="Test",
               meeting_date=datetime.now(timezone.utc),
               utterances=[u],
           )
           assert len(m.utterances) == 1
           assert m.utterances[0].text == "Hello everyone"

       def test_rejects_empty_title(self) -> None:
           """Meeting requires non-empty title."""
           with pytest.raises(ValueError, match="title cannot be empty"):
               Meeting(title="  ", meeting_date=datetime.now(timezone.utc))

       def test_serializes_to_json(self) -> None:
           """Meeting serializes to JSON correctly."""
           m = Meeting(
               title="Test",
               meeting_date=datetime(2024, 1, 15, 10, 0, tzinfo=timezone.utc),
           )
           json_str = m.model_dump_json()
           assert "Test" in json_str
           assert "2024-01-15" in json_str


   class TestActionItem:
       """Tests for ActionItem model."""

       def test_creates_with_required_fields(self) -> None:
           """ActionItem needs meeting_id and description."""
           meeting_id = uuid4()
           ai = ActionItem(
               meeting_id=meeting_id,
               description="Review the design doc",
           )
           assert ai.meeting_id == meeting_id
           assert ai.status == ActionItemStatus.OPEN
           assert ai.priority == ActionItemPriority.MEDIUM

       def test_creates_with_assignee(self) -> None:
           """ActionItem can have an assignee."""
           ai = ActionItem(
               meeting_id=uuid4(),
               description="Write tests",
               assignee_name="Bob",
               due_date=datetime(2024, 2, 1, tzinfo=timezone.utc),
           )
           assert ai.assignee_name == "Bob"
           assert ai.due_date is not None

       def test_rejects_empty_description(self) -> None:
           """ActionItem requires non-empty description."""
           with pytest.raises(ValueError, match="description cannot be empty"):
               ActionItem(meeting_id=uuid4(), description="   ")

       def test_confidence_bounds(self) -> None:
           """Confidence must be between 0 and 1."""
           with pytest.raises(ValueError):
               ActionItem(
                   meeting_id=uuid4(),
                   description="Test",
                   confidence=2.0,
               )


   class TestDecision:
       """Tests for Decision model."""

       def test_creates_with_required_fields(self) -> None:
           """Decision needs meeting_id and description."""
           d = Decision(
               meeting_id=uuid4(),
               description="We will use Python for the backend",
           )
           assert "Python" in d.description

       def test_creates_with_context(self) -> None:
           """Decision can include context and rationale."""
           d = Decision(
               meeting_id=uuid4(),
               description="Use Turso for database",
               context="Needed a SQLite-compatible cloud database",
               rationale="Matches existing stack, low latency",
               alternatives_considered=["PostgreSQL", "Supabase"],
           )
           assert len(d.alternatives_considered) == 2
           assert d.rationale is not None

       def test_rejects_empty_description(self) -> None:
           """Decision requires non-empty description."""
           with pytest.raises(ValueError, match="description cannot be empty"):
               Decision(meeting_id=uuid4(), description="")


   class TestRisk:
       """Tests for Risk model."""

       def test_creates_with_required_fields(self) -> None:
           """Risk needs meeting_id and description."""
           r = Risk(
               meeting_id=uuid4(),
               description="API rate limits could block integration",
           )
           assert r.severity == RiskSeverity.MEDIUM
           assert r.status == RiskStatus.IDENTIFIED

       def test_creates_with_all_fields(self) -> None:
           """Risk accepts all optional fields."""
           r = Risk(
               meeting_id=uuid4(),
               description="Vendor might deprecate API",
               severity=RiskSeverity.HIGH,
               status=RiskStatus.MITIGATING,
               likelihood="Medium",
               impact="Would require rewrite of integration",
               mitigation="Build abstraction layer",
               owner_name="Alice",
           )
           assert r.severity == RiskSeverity.HIGH
           assert r.mitigation is not None

       def test_rejects_empty_description(self) -> None:
           """Risk requires non-empty description."""
           with pytest.raises(ValueError, match="description cannot be empty"):
               Risk(meeting_id=uuid4(), description="   ")


   class TestIssue:
       """Tests for Issue model."""

       def test_creates_with_required_fields(self) -> None:
           """Issue needs meeting_id and description."""
           i = Issue(
               meeting_id=uuid4(),
               description="CI pipeline is failing intermittently",
           )
           assert i.priority == IssuePriority.MEDIUM
           assert i.status == IssueStatus.OPEN

       def test_creates_with_all_fields(self) -> None:
           """Issue accepts all optional fields."""
           action_id = uuid4()
           i = Issue(
               meeting_id=uuid4(),
               description="Database connections timing out",
               priority=IssuePriority.HIGH,
               status=IssueStatus.IN_PROGRESS,
               impact="Affecting user signups",
               resolution="Increasing connection pool size",
               owner_name="Charlie",
               related_action_ids=[action_id],
           )
           assert i.priority == IssuePriority.HIGH
           assert len(i.related_action_ids) == 1

       def test_rejects_empty_description(self) -> None:
           """Issue requires non-empty description."""
           with pytest.raises(ValueError, match="description cannot be empty"):
               Issue(meeting_id=uuid4(), description="")


   class TestModelSerialization:
       """Tests for model serialization/deserialization."""

       def test_meeting_round_trip(self) -> None:
           """Meeting can serialize and deserialize."""
           original = Meeting(
               title="Test Meeting",
               meeting_date=datetime(2024, 1, 15, 10, 0, tzinfo=timezone.utc),
               participants=[Participant(name="John")],
           )
           json_str = original.model_dump_json()
           restored = Meeting.model_validate_json(json_str)
           assert restored.title == original.title
           assert len(restored.participants) == 1

       def test_action_item_round_trip(self) -> None:
           """ActionItem can serialize and deserialize."""
           meeting_id = uuid4()
           original = ActionItem(
               meeting_id=meeting_id,
               description="Write docs",
               due_date=datetime(2024, 2, 1, tzinfo=timezone.utc),
           )
           json_str = original.model_dump_json()
           restored = ActionItem.model_validate_json(json_str)
           assert restored.meeting_id == meeting_id
           assert restored.due_date is not None

       def test_all_models_have_id(self) -> None:
           """All models inherit UUID id from BaseEntity."""
           meeting_id = uuid4()
           models = [
               Participant(name="Test"),
               Meeting(title="Test", meeting_date=datetime.now(timezone.utc)),
               ActionItem(meeting_id=meeting_id, description="Test"),
               Decision(meeting_id=meeting_id, description="Test"),
               Risk(meeting_id=meeting_id, description="Test"),
               Issue(meeting_id=meeting_id, description="Test"),
           ]
           for model in models:
               assert model.id is not None
               assert isinstance(model.id, type(uuid4()))
   ```

2. Run all tests:
   ```bash
   uv run pytest tests/ -v
   ```
  </action>
  <verify>
    Run: `uv run pytest tests/test_models.py -v`
    Expected: All tests pass (approximately 20+ tests)
  </verify>
  <done>
    Comprehensive model tests pass, validating all models work correctly.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `uv run pytest tests/test_models.py -v` - all model tests pass
2. `uv run python -c "from src.models import *; print('All models imported successfully')"` - imports work
3. All six models can be instantiated and serialized to JSON
</verification>

<success_criteria>
- All six canonical models defined (Meeting, Participant, ActionItem, Decision, Risk, Issue)
- Models have proper Pydantic v2 validators (field_validator, not @validator)
- Models reject invalid data with clear error messages
- Models serialize/deserialize correctly
- All model tests pass (20+ tests)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md` following the summary template.

Include:
- All model files created
- Field summary for each model
- Validation rules
- Test results
</output>
