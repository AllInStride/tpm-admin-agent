---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - uv.lock
  - .python-version
  - .gitignore
  - .env.example
  - .pre-commit-config.yaml
  - src/__init__.py
  - src/main.py
  - src/config.py
  - src/api/__init__.py
  - src/api/health.py
  - src/api/router.py
  - tests/__init__.py
  - tests/conftest.py
  - tests/test_api.py
autonomous: true

must_haves:
  truths:
    - "FastAPI application starts without errors"
    - "Health endpoint returns 200 with status healthy"
    - "Liveness and readiness probes respond correctly"
    - "Tests run successfully with pytest"
  artifacts:
    - path: "pyproject.toml"
      provides: "Project configuration and dependencies"
      contains: "fastapi"
    - path: "src/main.py"
      provides: "FastAPI application entry point"
      exports: ["app"]
    - path: "src/api/health.py"
      provides: "Health check endpoints"
      contains: "router"
    - path: "src/config.py"
      provides: "Application settings"
      contains: "Settings"
    - path: "tests/test_api.py"
      provides: "API endpoint tests"
      contains: "test_health"
  key_links:
    - from: "src/main.py"
      to: "src/api/router.py"
      via: "include_router"
      pattern: "app\\.include_router"
    - from: "src/api/router.py"
      to: "src/api/health.py"
      via: "include_router"
      pattern: "include_router.*health"
---

<objective>
Create the project scaffolding with uv, FastAPI, and health check endpoints.

Purpose: Establish the foundational project structure so all subsequent plans have a working Python environment, package management, and a running API.

Output: A fully initialized Python project with FastAPI that starts, responds to health checks, and has passing tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize project with uv and install dependencies</name>
  <files>
    pyproject.toml
    uv.lock
    .python-version
    .gitignore
    .env.example
    .pre-commit-config.yaml
  </files>
  <action>
1. Check if Python 3.12+ is available:
   ```bash
   python3 --version
   ```
   If not 3.12+, note this for user (but continue - uv will handle it).

2. Initialize the project with uv (from project root /Users/gabrielguenette/projects/tpm-admin-agent):
   ```bash
   uv init --name tpm-admin-agent --no-readme
   ```
   Note: If pyproject.toml already exists from uv init, that's fine.

3. Add production dependencies:
   ```bash
   uv add fastapi uvicorn pydantic python-dotenv structlog
   ```

4. Add Turso/libSQL client:
   ```bash
   uv add libsql-client
   ```

5. Add development dependencies:
   ```bash
   uv add --dev pytest pytest-asyncio ruff mypy pre-commit httpx
   ```

6. Create .gitignore with Python defaults:
   ```
   # Python
   __pycache__/
   *.py[cod]
   *$py.class
   *.so
   .Python
   build/
   develop-eggs/
   dist/
   downloads/
   eggs/
   .eggs/
   lib/
   lib64/
   parts/
   sdist/
   var/
   wheels/
   *.egg-info/
   .installed.cfg
   *.egg

   # Virtual environments
   .venv/
   venv/
   ENV/

   # IDE
   .idea/
   .vscode/
   *.swp
   *.swo

   # Environment
   .env
   .env.local

   # Testing
   .pytest_cache/
   .coverage
   htmlcov/
   .mypy_cache/
   .ruff_cache/

   # OS
   .DS_Store
   Thumbs.db
   ```

7. Create .env.example:
   ```
   # Database (Turso)
   TURSO_DATABASE_URL=libsql://your-database.turso.io
   TURSO_AUTH_TOKEN=your-auth-token

   # Application
   APP_ENV=development
   LOG_LEVEL=DEBUG
   ```

8. Create .pre-commit-config.yaml:
   ```yaml
   repos:
     - repo: https://github.com/astral-sh/ruff-pre-commit
       rev: v0.8.0
       hooks:
         - id: ruff
           args: [--fix]
         - id: ruff-format

     - repo: local
       hooks:
         - id: pytest
           name: pytest
           entry: uv run pytest tests -x --tb=short
           language: system
           types: [python]
           pass_filenames: false
           always_run: true
   ```

9. Install pre-commit hooks:
   ```bash
   uv run pre-commit install
   ```

10. Update pyproject.toml to add tool configurations (append to existing):
    ```toml
    [tool.ruff]
    line-length = 88
    target-version = "py312"

    [tool.ruff.lint]
    select = ["E", "F", "I", "N", "W", "UP"]

    [tool.pytest.ini_options]
    asyncio_mode = "auto"
    testpaths = ["tests"]
    asyncio_default_fixture_loop_scope = "function"

    [tool.mypy]
    python_version = "3.12"
    strict = false
    warn_return_any = true
    warn_unused_ignores = true
    ```
  </action>
  <verify>
    Run: `uv run python --version` - should show Python 3.12+
    Run: `ls pyproject.toml uv.lock` - both files should exist
  </verify>
  <done>
    Project initialized with uv, all dependencies installed, lock file generated, pre-commit hooks configured.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create FastAPI application with health endpoints</name>
  <files>
    src/__init__.py
    src/main.py
    src/config.py
    src/api/__init__.py
    src/api/health.py
    src/api/router.py
  </files>
  <action>
1. Create src directory and __init__.py:
   ```bash
   mkdir -p src/api
   ```

2. Create src/__init__.py (empty, marks as package):
   ```python
   """TPM Admin Agent - Meeting intelligence automation."""
   ```

3. Create src/config.py for application settings:
   ```python
   """Application configuration using pydantic-settings pattern."""

   from functools import lru_cache
   from typing import Optional

   from pydantic import Field
   from pydantic_settings import BaseSettings


   class Settings(BaseSettings):
       """Application settings loaded from environment variables."""

       # Application
       app_name: str = "TPM Admin Agent"
       app_version: str = "0.1.0"
       app_env: str = Field(default="development")
       log_level: str = Field(default="INFO")

       # Database (Turso)
       turso_database_url: Optional[str] = Field(default=None)
       turso_auth_token: Optional[str] = Field(default=None)

       model_config = {
           "env_file": ".env",
           "env_file_encoding": "utf-8",
           "extra": "ignore",
       }


   @lru_cache
   def get_settings() -> Settings:
       """Get cached settings instance."""
       return Settings()


   settings = get_settings()
   ```

4. Create src/api/__init__.py (empty):
   ```python
   """API routes for TPM Admin Agent."""
   ```

5. Create src/api/health.py with health check endpoints:
   ```python
   """Health check endpoints for monitoring and orchestration."""

   from datetime import datetime, timezone

   from fastapi import APIRouter
   from pydantic import BaseModel

   from src.config import settings

   router = APIRouter(prefix="/health", tags=["health"])


   class HealthResponse(BaseModel):
       """Response model for health check."""

       status: str
       timestamp: datetime
       version: str
       environment: str


   class LivenessResponse(BaseModel):
       """Response model for liveness probe."""

       status: str


   class ReadinessResponse(BaseModel):
       """Response model for readiness probe."""

       status: str
       checks: dict[str, str]


   @router.get("/", response_model=HealthResponse)
   async def health_check() -> HealthResponse:
       """Basic health check endpoint."""
       return HealthResponse(
           status="healthy",
           timestamp=datetime.now(timezone.utc),
           version=settings.app_version,
           environment=settings.app_env,
       )


   @router.get("/live", response_model=LivenessResponse)
   async def liveness() -> LivenessResponse:
       """Liveness probe - app is running."""
       return LivenessResponse(status="alive")


   @router.get("/ready", response_model=ReadinessResponse)
   async def readiness() -> ReadinessResponse:
       """Readiness probe - app can serve traffic.

       Note: Database check will be added in Plan 03 when event store is implemented.
       """
       checks = {
           "api": "ok",
           # "database": "ok" - added in Plan 03
       }
       status = "ready" if all(v == "ok" for v in checks.values()) else "not_ready"
       return ReadinessResponse(status=status, checks=checks)
   ```

6. Create src/api/router.py to aggregate routes:
   ```python
   """API router aggregation."""

   from fastapi import APIRouter

   from src.api.health import router as health_router

   api_router = APIRouter()
   api_router.include_router(health_router)
   ```

7. Create src/main.py as FastAPI entry point:
   ```python
   """FastAPI application entry point."""

   from contextlib import asynccontextmanager
   from typing import AsyncGenerator

   from fastapi import FastAPI

   from src.api.router import api_router
   from src.config import settings


   @asynccontextmanager
   async def lifespan(app: FastAPI) -> AsyncGenerator[None, None]:
       """Application lifespan management.

       Startup: Initialize resources (database connection added in Plan 03)
       Shutdown: Cleanup resources
       """
       # Startup
       # app.state.db will be initialized in Plan 03
       yield
       # Shutdown
       # Cleanup will be added in Plan 03


   app = FastAPI(
       title=settings.app_name,
       description="Meeting intelligence automation for TPMs",
       version=settings.app_version,
       lifespan=lifespan,
   )

   app.include_router(api_router)


   if __name__ == "__main__":
       import uvicorn

       uvicorn.run(
           "src.main:app",
           host="0.0.0.0",
           port=8000,
           reload=True,
       )
   ```

8. Add pydantic-settings dependency (needed for BaseSettings):
   ```bash
   uv add pydantic-settings
   ```
  </action>
  <verify>
    Run: `uv run uvicorn src.main:app --host 0.0.0.0 --port 8000 &`
    Wait 2 seconds, then:
    Run: `curl http://localhost:8000/health/`
    Expected: {"status":"healthy","timestamp":"...","version":"0.1.0","environment":"development"}
    Run: `curl http://localhost:8000/health/live`
    Expected: {"status":"alive"}
    Run: `curl http://localhost:8000/health/ready`
    Expected: {"status":"ready","checks":{"api":"ok"}}
    Kill the server after verification.
  </verify>
  <done>
    FastAPI application runs and all three health endpoints (/, /live, /ready) return correct responses.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create test harness and verify</name>
  <files>
    tests/__init__.py
    tests/conftest.py
    tests/test_api.py
  </files>
  <action>
1. Create tests directory:
   ```bash
   mkdir -p tests
   ```

2. Create tests/__init__.py (empty):
   ```python
   """Tests for TPM Admin Agent."""
   ```

3. Create tests/conftest.py with pytest fixtures:
   ```python
   """Pytest configuration and fixtures."""

   import pytest
   from httpx import ASGITransport, AsyncClient

   from src.main import app


   @pytest.fixture
   async def client() -> AsyncClient:
       """Create async test client for FastAPI app."""
       transport = ASGITransport(app=app)
       async with AsyncClient(transport=transport, base_url="http://test") as ac:
           yield ac
   ```

4. Create tests/test_api.py with health endpoint tests:
   ```python
   """Tests for API endpoints."""

   import pytest
   from httpx import AsyncClient


   @pytest.mark.asyncio
   async def test_health_check(client: AsyncClient) -> None:
       """Test basic health check endpoint."""
       response = await client.get("/health/")
       assert response.status_code == 200
       data = response.json()
       assert data["status"] == "healthy"
       assert "timestamp" in data
       assert data["version"] == "0.1.0"
       assert data["environment"] == "development"


   @pytest.mark.asyncio
   async def test_liveness(client: AsyncClient) -> None:
       """Test liveness probe endpoint."""
       response = await client.get("/health/live")
       assert response.status_code == 200
       data = response.json()
       assert data["status"] == "alive"


   @pytest.mark.asyncio
   async def test_readiness(client: AsyncClient) -> None:
       """Test readiness probe endpoint."""
       response = await client.get("/health/ready")
       assert response.status_code == 200
       data = response.json()
       assert data["status"] == "ready"
       assert "checks" in data
       assert data["checks"]["api"] == "ok"
   ```

5. Run tests to verify everything works:
   ```bash
   uv run pytest tests/ -v
   ```
  </action>
  <verify>
    Run: `uv run pytest tests/ -v`
    Expected: All 3 tests pass (test_health_check, test_liveness, test_readiness)
  </verify>
  <done>
    Test harness runs successfully, all health endpoint tests pass.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `uv run pytest tests/ -v` - all tests pass
2. `uv run uvicorn src.main:app --port 8000` starts without errors
3. `curl http://localhost:8000/health/` returns healthy status
4. `curl http://localhost:8000/docs` shows OpenAPI documentation
</verification>

<success_criteria>
- Project initialized with uv and all dependencies installed
- pyproject.toml has correct dependencies and tool configs
- FastAPI app starts and serves traffic
- Health endpoints (/, /live, /ready) all respond correctly
- Pytest runs and all 3 tests pass
- Pre-commit hooks installed
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md` following the summary template.

Include:
- Files created (full list)
- Dependencies installed
- Verification results (test output, curl responses)
- Any issues encountered and how resolved
</output>
