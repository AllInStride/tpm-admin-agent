---
phase: 05-output-generation
plan: 03
type: execute
wave: 3
depends_on: ["05-01", "05-02"]
files_modified:
  - src/output/router.py
  - src/output/queue.py
  - src/output/config.py
  - src/api/output.py
  - src/api/router.py
  - src/output/__init__.py
  - tests/test_output_router.py
  - tests/test_output_api.py
autonomous: true

must_haves:
  truths:
    - "OutputRouter routes minutes to Drive and RAID items to Sheets"
    - "Retry queue handles failed writes with exponential backoff"
    - "API endpoint accepts meeting ID and returns generated output URLs"
    - "User can select target system via project config"
    - "Dry-run mode available via API query parameter"
  artifacts:
    - path: "src/output/router.py"
      provides: "OutputRouter orchestrating adapters"
      exports: ["OutputRouter"]
    - path: "src/output/queue.py"
      provides: "Retry queue with tenacity"
      exports: ["write_with_retry", "RetryQueue"]
    - path: "src/output/config.py"
      provides: "ProjectOutputConfig for per-project settings"
      exports: ["ProjectOutputConfig"]
    - path: "src/api/output.py"
      provides: "Output generation API endpoint"
      exports: ["router"]
  key_links:
    - from: "src/output/router.py"
      to: "src/adapters/sheets_adapter.py"
      via: "SheetsAdapter injection"
      pattern: "SheetsAdapter"
    - from: "src/output/router.py"
      to: "src/adapters/drive_adapter.py"
      via: "DriveAdapter injection"
      pattern: "DriveAdapter"
    - from: "src/output/queue.py"
      to: "tenacity"
      via: "retry decorator"
      pattern: "@retry"
    - from: "src/api/output.py"
      to: "src/output/router.py"
      via: "OutputRouter import"
      pattern: "from src.output.router import"
---

<objective>
Create output routing, retry queue, and API endpoint to orchestrate the complete output generation pipeline.

Purpose: Connect all output components - renderer, adapters, and retry logic - into a cohesive pipeline exposed via API. This completes Phase 5 by enabling end-to-end meeting output generation.

Output: OutputRouter class that routes output to configured destinations, retry queue for reliability, and POST /api/output endpoint that generates and delivers meeting minutes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-output-generation/05-CONTEXT.md
@.planning/phases/05-output-generation/05-RESEARCH.md

@src/output/schemas.py (from 05-01)
@src/output/renderer.py (from 05-01)
@src/adapters/base.py (from 05-02)
@src/adapters/sheets_adapter.py (from 05-02)
@src/adapters/drive_adapter.py (from 05-02)
@src/api/router.py (to add output routes)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Project output config and retry queue</name>
  <files>
    src/output/config.py
    src/output/queue.py
  </files>
  <action>
    1. Create src/output/config.py with:

       ProjectOutputConfig (Pydantic model):
       - project_id: str | None = None (optional project identifier)
       - minutes_destination: str | None = None (Google Drive folder ID)
       - raid_destination: str | None = None (Google Sheets spreadsheet ID)
       - raid_sheet_name: str = "RAID" (worksheet name)
       - template_name: str = "default_minutes" (template to use)
       - enabled_targets: list[str] = ["drive", "sheets"] (which adapters to use)

       Add class method:
       - default() -> ProjectOutputConfig: Returns config with no destinations (dry-run safe)

    2. Create src/output/queue.py with tenacity retry logic:

       Import tenacity: retry, stop_after_attempt, wait_exponential, retry_if_exception_type, before_sleep_log

       Define retriable exceptions:
       - ConnectionError, TimeoutError, gspread.exceptions.APIError (if available)
       - googleapiclient.errors.HttpError (if available)

       Create write_with_retry decorator/wrapper:
       - stop_after_attempt(5) - max 5 retries
       - wait_exponential(multiplier=1, min=4, max=60) - exponential backoff
       - Log before each retry with structlog
       - Return WriteResult on success
       - Return WriteResult(success=False, error_message=...) after exhausted retries

       Create RetryQueue class (simple in-memory for now):
       - __init__(self): Initialize empty queue list
       - add(self, item: dict): Add failed item to queue
       - get_pending(self) -> list[dict]: Return queued items
       - clear(self): Empty the queue
       - __len__(self) -> int: Return queue length

       Note: Per CONTEXT.md, SQLite queue persistence is future work. In-memory is sufficient for MVP.
  </action>
  <verify>
    Run: python -c "
from src.output.config import ProjectOutputConfig
from src.output.queue import write_with_retry, RetryQueue

config = ProjectOutputConfig.default()
print(f'Default config: {config.template_name}')

queue = RetryQueue()
queue.add({'test': 'item'})
print(f'Queue length: {len(queue)}')
print('Config and queue OK')
"
  </verify>
  <done>
    - ProjectOutputConfig holds per-project output settings
    - write_with_retry uses tenacity exponential backoff
    - RetryQueue provides in-memory failed item storage
    - Default config safe for dry-run
  </done>
</task>

<task type="auto">
  <name>Task 2: OutputRouter orchestration</name>
  <files>
    src/output/router.py
    src/output/__init__.py
    tests/test_output_router.py
  </files>
  <action>
    1. Create src/output/router.py with OutputRouter class:

       __init__(
           self,
           renderer: MinutesRenderer | None = None,
           sheets_adapter: SheetsAdapter | None = None,
           drive_adapter: DriveAdapter | None = None,
       ):
       - Store adapters (allow None for testing without credentials)
       - Create default MinutesRenderer if not provided

       async def generate_output(
           self,
           context: MinutesContext,
           raid_bundle: RaidBundle,
           config: ProjectOutputConfig,
           *,
           dry_run: bool = False,
       ) -> OutputResult:
       - Render minutes using renderer
       - Route to adapters based on config.enabled_targets
       - Use write_with_retry for each adapter call
       - Collect all WriteResults
       - Log with structlog (audit trail per CONTEXT.md)
       - Return OutputResult with all write results

       async def route_minutes(
           self,
           minutes: RenderedMinutes,
           folder_id: str,
           *,
           dry_run: bool = False,
       ) -> WriteResult:
       - Generate filename: {meeting_date}-{meeting_title_slug}.md
       - Call drive_adapter.upload_minutes()
       - Return WriteResult

       async def route_raid_items(
           self,
           bundle: RaidBundle,
           spreadsheet_id: str,
           sheet_name: str = "RAID",
           *,
           dry_run: bool = False,
       ) -> WriteResult:
       - Convert RaidBundle to list of dicts with type field
       - Call sheets_adapter.write_raid_items()
       - Return WriteResult

       OutputResult (Pydantic model in same file):
       - rendered: RenderedMinutes
       - minutes_result: WriteResult | None
       - raid_result: WriteResult | None
       - total_items_written: int
       - all_successful: bool (computed property)

    2. Update src/output/__init__.py to export:
       - MinutesRenderer, MinutesContext, RenderedMinutes, RaidBundle (from schemas)
       - OutputRouter, OutputResult (from router)
       - ProjectOutputConfig (from config)

    3. Create tests/test_output_router.py:
       - test_generate_output_dry_run(): Full pipeline in dry-run mode
       - test_route_minutes_generates_filename(): Verify filename format
       - test_route_raid_items_includes_type(): Verify type field added to items
       - test_adapters_optional(): Verify router works with None adapters (dry-run only)
       - test_output_result_all_successful(): Verify computed property
       - test_audit_logging(): Verify structlog called with write details
       - test_config_enables_targets(): Verify enabled_targets filtering
       - test_retry_on_failure(): Mock adapter to fail, verify retry attempted

       Mock adapters for all tests - no real API calls.
  </action>
  <verify>
    Run: cd /Users/gabrielguenette/projects/tpm-admin-agent && uv run pytest tests/test_output_router.py -v
  </verify>
  <done>
    - OutputRouter orchestrates renderer and adapters
    - Minutes routed to Drive with proper filename
    - RAID items routed to Sheets with type field
    - Audit logging in place
    - 8 tests pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Output API endpoint</name>
  <files>
    src/api/output.py
    src/api/router.py
    tests/test_output_api.py
  </files>
  <action>
    1. Create src/api/output.py with FastAPI router:

       OutputRequest (Pydantic model):
       - meeting_id: UUID
       - meeting_title: str
       - meeting_date: datetime
       - duration_minutes: int | None = None
       - attendees: list[str]
       - decisions: list[dict] (raw RAID data)
       - action_items: list[dict]
       - risks: list[dict]
       - issues: list[dict]
       - config: ProjectOutputConfig | None = None (optional, uses default)

       OutputResponse (Pydantic model):
       - success: bool
       - meeting_id: UUID
       - minutes_url: str | None
       - sheets_url: str | None
       - markdown_preview: str (truncated to 500 chars)
       - items_written: int
       - errors: list[str]

       POST /api/output:
       - Query params: dry_run: bool = False
       - Body: OutputRequest
       - Build MinutesContext from request
       - Build RaidBundle from request
       - Get or create OutputRouter (dependency injection)
       - Call router.generate_output()
       - Return OutputResponse with results

       GET /api/output/health:
       - Check adapter health (if configured)
       - Return {"status": "ok", "adapters": {...}}

    2. Update src/api/router.py:
       - Import output router: from src.api.output import router as output_router
       - Include router: api_router.include_router(output_router, prefix="/output", tags=["output"])

    3. Create tests/test_output_api.py:
       - test_output_endpoint_dry_run(): POST with dry_run=true, verify 200 response
       - test_output_endpoint_returns_preview(): Verify markdown_preview in response
       - test_output_endpoint_with_config(): Provide custom config, verify used
       - test_output_endpoint_missing_meeting_id(): Verify 422 validation error
       - test_output_health_endpoint(): GET /api/output/health returns status
       - test_output_endpoint_with_raid_items(): Full request with all RAID types
       - test_output_endpoint_empty_raid(): Request with empty RAID lists

       Use TestClient from httpx. Mock OutputRouter for controlled testing.
  </action>
  <verify>
    Run: cd /Users/gabrielguenette/projects/tpm-admin-agent && uv run pytest tests/test_output_api.py -v
  </verify>
  <done>
    - POST /api/output accepts meeting data and config
    - dry_run query param available
    - Response includes minutes_url, sheets_url, preview
    - Health endpoint reports adapter status
    - 7 tests pass
  </done>
</task>

</tasks>

<verification>
1. `python -c "from src.output import OutputRouter, ProjectOutputConfig"` works
2. `uv run pytest tests/test_output_router.py tests/test_output_api.py -v` - all tests pass
3. `curl -X POST http://localhost:8000/api/output?dry_run=true -H "Content-Type: application/json" -d '{"meeting_id":"...", ...}'` returns 200
4. Full pipeline works: Request -> Render -> Route -> Response
5. Retry logic handles transient failures
</verification>

<success_criteria>
- ProjectOutputConfig enables per-project destination configuration
- RetryQueue with tenacity handles failed writes
- OutputRouter orchestrates renderer and adapters
- POST /api/output generates and delivers meeting output
- Dry-run mode available via query parameter
- Audit logging tracks all write operations
- 15+ tests pass covering router and API
</success_criteria>

<output>
After completion, create `.planning/phases/05-output-generation/05-03-SUMMARY.md`
</output>
