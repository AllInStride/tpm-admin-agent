---
phase: 04-identity-resolution
plan: 04
type: execute
wave: 3
depends_on: [04-02]
files_modified:
  - src/adapters/slack_adapter.py
  - src/adapters/calendar_adapter.py
  - src/adapters/__init__.py
  - src/identity/resolver.py
  - tests/adapters/test_slack_adapter.py
  - tests/adapters/test_calendar_adapter.py
  - tests/identity/test_resolver_multi_source.py
autonomous: true
user_setup:
  - service: slack
    why: "Cross-referencing Slack channel membership (IDN-02)"
    env_vars:
      - name: SLACK_BOT_TOKEN
        source: "Slack API -> Your Apps -> OAuth & Permissions -> Bot User OAuth Token (xoxb-...)"
    dashboard_config:
      - task: "Create Slack app with users:read and channels:read scopes"
        location: "api.slack.com/apps -> Create New App -> OAuth & Permissions"
      - task: "Install app to workspace"
        location: "Slack App -> Install to Workspace"
  - service: google-calendar
    why: "Cross-referencing Calendar attendees (IDN-03)"
    env_vars:
      - name: GOOGLE_CALENDAR_CREDENTIALS
        source: "Same service account as Google Sheets - ensure Calendar API enabled"
    dashboard_config:
      - task: "Enable Google Calendar API"
        location: "GCP Console -> APIs & Services -> Library -> Google Calendar API -> Enable"

must_haves:
  truths:
    - "System cross-references Slack channel membership for verification (IDN-02)"
    - "System cross-references Google Calendar attendees for verification (IDN-03)"
    - "Multi-source agreement boosts confidence above 85%"
    - "Verification is optional - resolution works without Slack/Calendar"
  artifacts:
    - path: "src/adapters/slack_adapter.py"
      provides: "SlackAdapter for channel membership lookup"
      exports: ["SlackAdapter"]
    - path: "src/adapters/calendar_adapter.py"
      provides: "CalendarAdapter for meeting attendees"
      exports: ["CalendarAdapter"]
  key_links:
    - from: "src/identity/resolver.py"
      to: "src/adapters/slack_adapter.py"
      via: "Optional SlackAdapter for verification"
      pattern: "slack_adapter.*verify"
    - from: "src/identity/resolver.py"
      to: "src/adapters/calendar_adapter.py"
      via: "Optional CalendarAdapter for verification"
      pattern: "calendar_adapter.*verify"
---

<objective>
Create Slack and Calendar adapters for multi-source identity verification.

Purpose: Per CONTEXT.md, single-source matches (roster only) are capped at 85%. When Slack or Calendar corroborate a match, confidence can exceed 85%. These adapters enable the multi-source verification that improves match quality.
Output: SlackAdapter, CalendarAdapter, updated resolver with multi-source verification
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-identity-resolution/04-CONTEXT.md
@.planning/phases/04-identity-resolution/04-RESEARCH.md
@src/identity/resolver.py
@src/identity/confidence.py
@src/adapters/roster_adapter.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Slack SDK and create SlackAdapter</name>
  <files>
    - pyproject.toml
    - src/adapters/slack_adapter.py
    - src/adapters/__init__.py
    - tests/adapters/test_slack_adapter.py
  </files>
  <action>
1. Add slack-sdk>=3.35.0 to dependencies in pyproject.toml

2. Create src/adapters/slack_adapter.py:

```python
class SlackAdapter:
    """Adapter for Slack workspace member verification.

    Uses Slack Web API to verify that an email exists in the workspace
    and optionally in specific channels.
    """

    def __init__(self, bot_token: str | None = None):
        """Initialize with bot token.

        Args:
            bot_token: Slack bot token (xoxb-...).
                      Falls back to SLACK_BOT_TOKEN env var.
        """
        self._token = bot_token or os.environ.get("SLACK_BOT_TOKEN")
        self._client: WebClient | None = None

    def _get_client(self) -> WebClient:
        """Get or create Slack client."""
        if self._client is None:
            if not self._token:
                raise ValueError(
                    "No Slack token. Set SLACK_BOT_TOKEN env var "
                    "or pass bot_token to constructor."
                )
            self._client = WebClient(token=self._token)
        return self._client

    async def verify_member(self, email: str) -> bool:
        """Check if email exists as Slack workspace member.

        Args:
            email: Email address to verify

        Returns:
            True if member exists in workspace
        """
        try:
            client = self._get_client()
            # Use users.lookupByEmail API
            result = client.users_lookupByEmail(email=email)
            return result.get("ok", False)
        except SlackApiError as e:
            if e.response.get("error") == "users_not_found":
                return False
            logger.warning(f"Slack API error verifying {email}: {e}")
            return False
        except Exception as e:
            logger.warning(f"Error verifying Slack member {email}: {e}")
            return False

    async def get_channel_members(self, channel_id: str) -> set[str]:
        """Get email addresses of channel members.

        Args:
            channel_id: Slack channel ID

        Returns:
            Set of email addresses in channel
        """
        try:
            client = self._get_client()
            # Get member IDs
            members_result = client.conversations_members(channel=channel_id)
            member_ids = members_result.get("members", [])

            # Get email for each member
            emails = set()
            for member_id in member_ids:
                try:
                    user_result = client.users_info(user=member_id)
                    user = user_result.get("user", {})
                    profile = user.get("profile", {})
                    if email := profile.get("email"):
                        emails.add(email.lower())
                except SlackApiError:
                    continue
            return emails
        except Exception as e:
            logger.warning(f"Error getting channel members: {e}")
            return set()
```

3. Update src/adapters/__init__.py to export SlackAdapter

4. Create tests/adapters/test_slack_adapter.py:
   - test_verify_member_returns_true_when_found
   - test_verify_member_returns_false_when_not_found
   - test_verify_member_handles_api_error
   - test_get_channel_members_returns_emails
   - test_no_token_raises_value_error

Use mock for WebClient.

5. Run `uv sync`
  </action>
  <verify>
    - `python -c "from slack_sdk import WebClient; print('Slack SDK installed')"` succeeds
    - `pytest tests/adapters/test_slack_adapter.py -v` all tests pass
    - SlackAdapter.verify_member returns bool
  </verify>
  <done>SlackAdapter verifies Slack workspace membership by email</done>
</task>

<task type="auto">
  <name>Task 2: Create CalendarAdapter for meeting attendees</name>
  <files>
    - src/adapters/calendar_adapter.py
    - src/adapters/__init__.py
    - tests/adapters/test_calendar_adapter.py
  </files>
  <action>
1. Create src/adapters/calendar_adapter.py:

```python
class CalendarAdapter:
    """Adapter for Google Calendar attendee verification.

    Uses Google Calendar API to get meeting attendees for cross-reference.
    """

    def __init__(self, credentials_path: str | None = None):
        """Initialize with service account credentials.

        Args:
            credentials_path: Path to service account JSON.
                             Falls back to GOOGLE_CALENDAR_CREDENTIALS or
                             GOOGLE_SHEETS_CREDENTIALS env vars.
        """
        self._credentials_path = (
            credentials_path
            or os.environ.get("GOOGLE_CALENDAR_CREDENTIALS")
            or os.environ.get("GOOGLE_SHEETS_CREDENTIALS")
        )
        self._service = None

    def _get_service(self):
        """Get or create Calendar API service."""
        if self._service is None:
            if not self._credentials_path:
                raise ValueError(
                    "No credentials. Set GOOGLE_CALENDAR_CREDENTIALS env var "
                    "or pass credentials_path to constructor."
                )
            creds = ServiceAccountCredentials.from_service_account_file(
                self._credentials_path,
                scopes=["https://www.googleapis.com/auth/calendar.readonly"]
            )
            self._service = build("calendar", "v3", credentials=creds)
        return self._service

    async def get_event_attendees(
        self,
        calendar_id: str,
        event_id: str
    ) -> list[dict]:
        """Get attendees for a calendar event.

        Args:
            calendar_id: Calendar ID (usually primary user's email)
            event_id: Event ID from calendar

        Returns:
            List of attendee dicts with email, displayName, responseStatus
        """
        try:
            service = self._get_service()
            event = service.events().get(
                calendarId=calendar_id,
                eventId=event_id
            ).execute()
            return event.get("attendees", [])
        except Exception as e:
            logger.warning(f"Error getting calendar event: {e}")
            return []

    async def verify_attendee(
        self,
        calendar_id: str,
        event_id: str,
        email: str
    ) -> bool:
        """Check if email was attendee of calendar event.

        Args:
            calendar_id: Calendar ID
            event_id: Event ID
            email: Email to verify

        Returns:
            True if email was attendee
        """
        attendees = await self.get_event_attendees(calendar_id, event_id)
        attendee_emails = {
            a.get("email", "").lower()
            for a in attendees
            if a.get("email")
        }
        return email.lower() in attendee_emails

    async def find_meeting_by_time(
        self,
        calendar_id: str,
        meeting_time: datetime,
        tolerance_minutes: int = 15
    ) -> str | None:
        """Find event ID by meeting time.

        Args:
            calendar_id: Calendar ID
            meeting_time: When meeting occurred
            tolerance_minutes: Minutes before/after to search

        Returns:
            Event ID if found, None otherwise
        """
        try:
            service = self._get_service()
            time_min = (meeting_time - timedelta(minutes=tolerance_minutes)).isoformat() + "Z"
            time_max = (meeting_time + timedelta(minutes=tolerance_minutes)).isoformat() + "Z"

            events_result = service.events().list(
                calendarId=calendar_id,
                timeMin=time_min,
                timeMax=time_max,
                maxResults=5,
                singleEvents=True
            ).execute()

            events = events_result.get("items", [])
            if events:
                return events[0].get("id")
            return None
        except Exception as e:
            logger.warning(f"Error finding meeting: {e}")
            return None
```

2. Update src/adapters/__init__.py to export CalendarAdapter

3. Add google-api-python-client>=2.170.0 to pyproject.toml dependencies (if not already there for gspread)

4. Create tests/adapters/test_calendar_adapter.py:
   - test_get_event_attendees_returns_list
   - test_verify_attendee_returns_true_when_present
   - test_verify_attendee_returns_false_when_absent
   - test_find_meeting_by_time_returns_event_id
   - test_handles_api_error_gracefully

Use mock for Calendar API service.

5. Run `uv sync`
  </action>
  <verify>
    - `pytest tests/adapters/test_calendar_adapter.py -v` all tests pass
    - CalendarAdapter.verify_attendee returns bool
    - CalendarAdapter.get_event_attendees returns list of dicts
  </verify>
  <done>CalendarAdapter verifies meeting attendees from Google Calendar</done>
</task>

<task type="auto">
  <name>Task 3: Update IdentityResolver with multi-source verification</name>
  <files>
    - src/identity/resolver.py
    - tests/identity/test_resolver_multi_source.py
  </files>
  <action>
1. Update src/identity/resolver.py to add optional verification:

```python
class IdentityResolver:
    def __init__(
        self,
        fuzzy_matcher: FuzzyMatcher,
        mapping_repo: MappingRepository,
        llm_matcher: LLMMatcher | None = None,
        slack_adapter: SlackAdapter | None = None,
        calendar_adapter: CalendarAdapter | None = None,
        auto_accept_threshold: float = 0.85,
    ):
        # ... existing init
        self._slack = slack_adapter
        self._calendar = calendar_adapter

    async def resolve(
        self,
        transcript_name: str,
        roster: list[RosterEntry],
        project_id: str,
        calendar_event_id: str | None = None,
        calendar_id: str | None = None,
    ) -> ResolutionResult:
        """Resolve with optional multi-source verification."""
        # ... existing pipeline stages ...

        # After fuzzy match, apply multi-source verification
        if match and score >= self._threshold:
            # Check secondary sources
            slack_verified = False
            calendar_verified = False

            if self._slack:
                slack_verified = await self._slack.verify_member(match.email)

            if self._calendar and calendar_event_id and calendar_id:
                calendar_verified = await self._calendar.verify_attendee(
                    calendar_id, calendar_event_id, match.email
                )

            # Calculate boosted confidence
            final_confidence = calculate_confidence(
                fuzzy_score=score,
                roster_match=True,
                slack_match=slack_verified,
                calendar_match=calendar_verified,
            )

            return ResolutionResult(
                transcript_name=transcript_name,
                resolved_email=match.email,
                resolved_name=match.name,
                confidence=final_confidence,
                source=ResolutionSource.FUZZY,
                alternatives=[(e.name, s) for e, s in alternatives if e.email != match.email],
                requires_review=final_confidence < 0.85
            )
        # ... rest of method
```

2. Create tests/identity/test_resolver_multi_source.py:
   - test_slack_verification_boosts_confidence
   - test_calendar_verification_boosts_confidence
   - test_both_sources_boost_higher
   - test_no_adapters_caps_at_85
   - test_verification_failure_still_resolves
   - test_calendar_params_optional

Use mocks for adapters.
  </action>
  <verify>
    - `pytest tests/identity/test_resolver_multi_source.py -v` all tests pass
    - Multi-source verification boosts confidence above 85%
    - Resolution works without adapters (graceful degradation)
  </verify>
  <done>IdentityResolver uses multi-source verification to boost confidence when Slack/Calendar corroborate matches</done>
</task>

</tasks>

<verification>
- All adapter tests pass: `pytest tests/adapters/ -v`
- Multi-source tests pass: `pytest tests/identity/test_resolver_multi_source.py -v`
- Full test suite: `pytest tests/ -v` all pass
- Slack adapter verifies membership
- Calendar adapter verifies attendees
- Resolver uses calculate_confidence for multi-source boosting
</verification>

<success_criteria>
- Slack SDK dependency added and installed
- SlackAdapter verifies workspace membership by email
- CalendarAdapter gets attendees and verifies by email
- IdentityResolver accepts optional SlackAdapter and CalendarAdapter
- Multi-source verification uses calculate_confidence from Plan 01
- Verification is optional - works without adapters (caps at 85%)
- All tests pass (16+ new tests)
- Requirements covered: IDN-02 (Slack), IDN-03 (Calendar)
</success_criteria>

<output>
After completion, create `.planning/phases/04-identity-resolution/04-04-SUMMARY.md`
</output>
