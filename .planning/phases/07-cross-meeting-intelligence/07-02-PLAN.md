---
phase: 07-cross-meeting-intelligence
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/search/open_items.py
  - src/repositories/open_items_repo.py
  - tests/repositories/test_open_items_repo.py
  - tests/test_open_items.py
autonomous: true

must_haves:
  truths:
    - "Open items are identified by centralized definition"
    - "Dashboard queries return items grouped by due date, owner, or project"
    - "Overdue items are correctly identified"
    - "Item status can be updated (close action)"
  artifacts:
    - path: "src/search/open_items.py"
      provides: "Open item definition and logic"
      exports: ["is_item_open", "OpenItemSummary", "OpenItemFilter"]
    - path: "src/repositories/open_items_repo.py"
      provides: "Database queries for open items"
      exports: ["OpenItemsRepository"]
  key_links:
    - from: "src/repositories/open_items_repo.py"
      to: "src/repositories/projection_repo.py"
      via: "queries raid_items_projection table"
      pattern: "raid_items_projection"
    - from: "src/search/open_items.py"
      to: "src/repositories/open_items_repo.py"
      via: "OpenItemsRepository for data access"
      pattern: "OpenItemsRepository"
---

<objective>
Create open item tracking and dashboard query capabilities.

Purpose: TPMs need to see what's open across all meetings. This plan creates the single source of truth for "open" definition and efficient queries for dashboard groupings.

Output: Centralized is_item_open() function, OpenItemsRepository with aggregation queries, filter/grouping support.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-cross-meeting-intelligence/07-CONTEXT.md
@.planning/phases/07-cross-meeting-intelligence/07-RESEARCH.md

# Existing patterns
@src/repositories/mapping_repo.py
@src/db/turso.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Open item definition and schemas</name>
  <files>
    src/search/open_items.py
    tests/test_open_items.py
  </files>
  <action>
Create centralized open item logic per RESEARCH.md Pitfall 3.

**src/search/open_items.py:**

Define constants for closed statuses:
```python
CLOSED_STATUSES = frozenset({'completed', 'cancelled', 'closed', 'resolved'})
```

Create `is_item_open(status: str) -> bool`:
```python
def is_item_open(status: str | None) -> bool:
    """Single source of truth for 'open' definition.

    An item is open if its status is not in the closed set.
    Items with None status are considered open (default state).
    """
    if status is None:
        return True
    return status.lower() not in CLOSED_STATUSES
```

Create Pydantic schemas:

`OpenItemFilter`:
- item_type: str | None = None  # 'action', 'decision', 'risk', 'issue'
- owner: str | None = None
- meeting_id: str | None = None
- overdue_only: bool = False
- due_within_days: int | None = None  # e.g., 7 for "due this week"

`OpenItemSummary`:
- total: int
- overdue: int
- due_today: int
- due_this_week: int
- by_type: dict[str, int]  # {'action': 5, 'risk': 2, ...}

`GroupedOpenItems`:
- summary: OpenItemSummary
- items: list[dict]  # Raw item dicts with all fields
- group_by: str  # 'due_date', 'owner', 'item_type'

**tests/test_open_items.py:**
- Test is_item_open('pending') -> True
- Test is_item_open('completed') -> False
- Test is_item_open('cancelled') -> False
- Test is_item_open('closed') -> False
- Test is_item_open('resolved') -> False
- Test is_item_open(None) -> True
- Test is_item_open('COMPLETED') -> False (case insensitive)
- Test OpenItemFilter validation
- Test OpenItemSummary serialization
  </action>
  <verify>
Run tests: `uv run pytest tests/test_open_items.py -v`
All tests pass. Open definition is consistent.
  </verify>
  <done>
is_item_open() provides single source of truth. Schemas defined for filtering and summaries. 8+ tests passing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Open items repository</name>
  <files>
    src/repositories/open_items_repo.py
    tests/repositories/test_open_items_repo.py
  </files>
  <action>
Create repository for efficient open items queries per RESEARCH.md Pitfall 5.

**src/repositories/open_items_repo.py:**
Create `OpenItemsRepository`:
- `__init__(self, db_client: TursoClient)`

- `async def get_summary(self) -> OpenItemSummary`:
  Single query for all counts (avoid N+1):
  ```sql
  SELECT
      COUNT(*) as total,
      COUNT(*) FILTER (WHERE date(due_date) < date('now')) as overdue,
      COUNT(*) FILTER (WHERE date(due_date) = date('now')) as due_today,
      COUNT(*) FILTER (WHERE date(due_date) > date('now')
          AND date(due_date) <= date('now', '+7 days')) as due_this_week
  FROM raid_items_projection
  WHERE status NOT IN ('completed', 'cancelled', 'closed', 'resolved')
  ```

  Also get counts by type:
  ```sql
  SELECT item_type, COUNT(*) as count
  FROM raid_items_projection
  WHERE status NOT IN ('completed', 'cancelled', 'closed', 'resolved')
  GROUP BY item_type
  ```

  Combine into OpenItemSummary.

- `async def get_items(self, filter: OpenItemFilter, group_by: str = 'due_date') -> GroupedOpenItems`:
  Build query based on filter:
  - Base WHERE: status NOT IN closed statuses
  - If filter.item_type: AND item_type = ?
  - If filter.owner: AND owner = ?
  - If filter.meeting_id: AND meeting_id = ?
  - If filter.overdue_only: AND date(due_date) < date('now')
  - If filter.due_within_days: AND date(due_date) <= date('now', '+{N} days')

  ORDER BY based on group_by:
  - 'due_date': ORDER BY CASE WHEN due_date IS NULL THEN 1 ELSE 0 END, due_date ASC
  - 'owner': ORDER BY owner, due_date
  - 'item_type': ORDER BY item_type, due_date

  Return GroupedOpenItems with summary from get_summary() and filtered items.

- `async def close_item(self, item_id: str, new_status: str = 'completed') -> bool`:
  Update item status in raid_items_projection:
  ```sql
  UPDATE raid_items_projection
  SET status = ?
  WHERE id = ?
  ```
  Return rows_affected > 0.

Note: This repository queries raid_items_projection table created by Plan 07-01. For tests, create the table schema directly (don't depend on 07-01 being run first).

**tests/repositories/test_open_items_repo.py:**
Setup: Create raid_items_projection table and insert test data.
- Test get_summary returns correct counts for overdue, due_today, due_this_week
- Test get_summary by_type counts
- Test get_items with no filter returns all open items
- Test get_items with item_type filter
- Test get_items with owner filter
- Test get_items with overdue_only=True
- Test get_items with due_within_days=7
- Test get_items group_by='owner' orders correctly
- Test close_item updates status and returns True
- Test close_item returns False for non-existent item
  </action>
  <verify>
Run tests: `uv run pytest tests/repositories/test_open_items_repo.py -v`
All tests pass. Queries return correct data.
  </verify>
  <done>
OpenItemsRepository provides efficient dashboard queries. Summary aggregates in single query. Filtering and grouping work. close_item updates status. 10+ tests passing.
  </done>
</task>

<task type="auto">
  <name>Task 3: Item history queries</name>
  <files>
    src/repositories/open_items_repo.py (extend)
    src/search/open_items.py (extend)
    tests/repositories/test_open_items_repo.py (extend)
  </files>
  <action>
Add item history capability for timeline view.

**src/search/open_items.py (extend):**
Add schema:

`ItemHistoryEntry`:
- timestamp: datetime
- event_type: str
- change_type: str  # 'created', 'updated', 'mentioned'
- meeting_id: str | None
- meeting_title: str | None
- meeting_date: str | None

`ItemHistory`:
- item_id: str
- item_type: str
- description: str
- current_status: str
- entries: list[ItemHistoryEntry]

Add helper function:
```python
def classify_change(event_type: str) -> str:
    """Classify event into change type for timeline display."""
    if 'Extracted' in event_type:
        return 'created'
    if 'Updated' in event_type:
        return 'updated'
    return 'mentioned'
```

**src/repositories/open_items_repo.py (extend):**
Add method:

- `async def get_item_history(self, item_id: str) -> ItemHistory | None`:
  1. Get current item from raid_items_projection
  2. Query events table for all events referencing this item:
     ```sql
     SELECT e.timestamp, e.event_type, e.event_data, e.aggregate_id
     FROM events e
     WHERE e.aggregate_id = ?
        OR e.event_data LIKE ?
     ORDER BY e.timestamp ASC
     ```
     (Pass item_id and f'%"{item_id}"%' for JSON containment)

  3. For each event, join with meetings_projection to get meeting context:
     - Parse event_data JSON to get meeting_id
     - Look up meeting title/date from meetings_projection

  4. Build ItemHistory with entries.

If item doesn't exist, return None.

**tests/repositories/test_open_items_repo.py (extend):**
Setup: Also create events table and meetings_projection for history tests.
- Test get_item_history returns entries in chronological order
- Test get_item_history includes meeting context
- Test get_item_history returns None for non-existent item
- Test classify_change correctly categorizes event types
  </action>
  <verify>
Run tests: `uv run pytest tests/repositories/test_open_items_repo.py -v`
All tests pass including history tests.
  </verify>
  <done>
Item history queries return timeline of events with meeting context. classify_change() maps event types. 4+ additional tests passing.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `uv run pytest tests/test_open_items.py tests/repositories/test_open_items_repo.py -v` - all pass
2. `uv run pytest` - full suite still passes
3. Verify is_item_open is the only place that defines "open" logic
</verification>

<success_criteria>
- is_item_open() is single source of truth for open definition
- Dashboard summary query runs in single SQL statement (no N+1)
- Filtering by type, owner, meeting, overdue works
- Grouping by due_date, owner, item_type works
- Item status can be updated via close_item()
- Item history returns chronological event entries
- 20+ new tests passing
</success_criteria>

<output>
After completion, create `.planning/phases/07-cross-meeting-intelligence/07-02-SUMMARY.md`
</output>
