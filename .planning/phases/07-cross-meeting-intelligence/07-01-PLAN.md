---
phase: 07-cross-meeting-intelligence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/search/__init__.py
  - src/search/schemas.py
  - src/search/projections.py
  - src/repositories/projection_repo.py
  - tests/test_projections.py
autonomous: true

must_haves:
  truths:
    - "Meeting data materializes into searchable projection tables"
    - "RAID items materialize into searchable projection tables"
    - "FTS5 indexes stay synchronized with projection tables"
    - "Projections can rebuild from event store"
  artifacts:
    - path: "src/search/schemas.py"
      provides: "Projection schema definitions"
      exports: ["MeetingProjection", "RaidItemProjection", "TranscriptProjection"]
    - path: "src/search/projections.py"
      provides: "Projection builder from events"
      exports: ["ProjectionBuilder"]
    - path: "src/repositories/projection_repo.py"
      provides: "Database operations for projections"
      exports: ["ProjectionRepository"]
  key_links:
    - from: "src/search/projections.py"
      to: "src/events/store.py"
      via: "get_all_events for rebuild"
      pattern: "event_store\\.get_all_events"
    - from: "src/repositories/projection_repo.py"
      to: "src/db/turso.py"
      via: "TursoClient for FTS5 operations"
      pattern: "TursoClient"
---

<objective>
Create the read projection infrastructure for cross-meeting intelligence.

Purpose: Event store is append-only and optimized for writes, not queries. Projections materialize queryable state from events, enabling fast search and dashboard queries.

Output: Projection schemas, ProjectionRepository with FTS5 tables, ProjectionBuilder that materializes events into searchable projections.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-cross-meeting-intelligence/07-RESEARCH.md

# Existing patterns
@src/events/store.py
@src/events/types.py
@src/repositories/mapping_repo.py
@src/db/turso.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Projection schemas and repository</name>
  <files>
    src/search/__init__.py
    src/search/schemas.py
    src/repositories/projection_repo.py
    tests/repositories/test_projection_repo.py
  </files>
  <action>
Create projection infrastructure for searchable read models.

**src/search/schemas.py:**
Define Pydantic models for projections:
- `MeetingProjection`: id, title, date, participant_count, created_at
- `RaidItemProjection`: id, meeting_id, item_type (action/decision/risk/issue), description, owner, due_date, status (pending/completed/cancelled/closed/resolved), confidence, created_at
- `TranscriptProjection`: id, meeting_id, speaker, text, start_time, created_at

**src/repositories/projection_repo.py:**
Create `ProjectionRepository` class following existing pattern from `mapping_repo.py`:
- `__init__(self, db_client: TursoClient)` - store db reference
- `async def initialize(self) -> None` - create tables and FTS5 indexes:

Tables to create:
```sql
-- Meetings projection
CREATE TABLE IF NOT EXISTS meetings_projection (
    id TEXT PRIMARY KEY,
    title TEXT NOT NULL,
    date TEXT,
    participant_count INTEGER DEFAULT 0,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
);

-- RAID items projection
CREATE TABLE IF NOT EXISTS raid_items_projection (
    id TEXT PRIMARY KEY,
    meeting_id TEXT NOT NULL,
    item_type TEXT NOT NULL,
    description TEXT NOT NULL,
    owner TEXT,
    due_date TEXT,
    status TEXT DEFAULT 'pending',
    confidence REAL DEFAULT 1.0,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
);

-- Transcripts projection (utterances)
CREATE TABLE IF NOT EXISTS transcripts_projection (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    meeting_id TEXT NOT NULL,
    speaker TEXT,
    text TEXT NOT NULL,
    start_time REAL,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
);

-- FTS5 for RAID items (external content)
CREATE VIRTUAL TABLE IF NOT EXISTS raid_items_fts USING fts5(
    description,
    owner,
    content='raid_items_projection',
    content_rowid='rowid',
    tokenize='porter unicode61'
);

-- FTS5 for transcripts (external content)
CREATE VIRTUAL TABLE IF NOT EXISTS transcripts_fts USING fts5(
    speaker,
    text,
    content='transcripts_projection',
    content_rowid='rowid',
    tokenize='porter unicode61'
);
```

Add sync triggers for FTS5 (per RESEARCH.md Pattern 2):
- AFTER INSERT trigger on raid_items_projection -> insert into raid_items_fts
- AFTER DELETE trigger on raid_items_projection -> delete from raid_items_fts
- Same pair for transcripts_projection -> transcripts_fts

Repository methods:
- `async def upsert_meeting(self, projection: MeetingProjection) -> None`
- `async def upsert_raid_item(self, projection: RaidItemProjection) -> None`
- `async def insert_transcript_utterance(self, projection: TranscriptProjection) -> None`
- `async def update_item_status(self, item_id: str, status: str) -> bool`
- `async def get_meeting(self, meeting_id: str) -> MeetingProjection | None`
- `async def get_raid_item(self, item_id: str) -> RaidItemProjection | None`

Important: Use individual `execute()` calls for FTS5 operations, NOT `execute_batch()` per RESEARCH.md Pitfall 1.

**src/search/__init__.py:**
Export schemas: MeetingProjection, RaidItemProjection, TranscriptProjection

**tests/repositories/test_projection_repo.py:**
- Test table creation (initialize)
- Test upsert_meeting creates and updates
- Test upsert_raid_item creates and updates
- Test insert_transcript_utterance
- Test update_item_status returns True/False correctly
- Test FTS5 sync (insert item, verify searchable in FTS table)
  </action>
  <verify>
Run tests: `uv run pytest tests/repositories/test_projection_repo.py -v`
All tests pass. Tables created correctly. FTS5 triggers working.
  </verify>
  <done>
ProjectionRepository creates projection tables with FTS5 indexes. CRUD operations work. FTS5 stays synchronized via triggers. 6+ tests passing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Projection builder from events</name>
  <files>
    src/search/projections.py
    tests/test_projections.py
  </files>
  <action>
Create ProjectionBuilder that materializes events into projections.

**src/search/projections.py:**
Create `ProjectionBuilder` class:
- `__init__(self, event_store: EventStore, projection_repo: ProjectionRepository)`

- `async def handle_event(self, event_data: dict) -> None`
  Route event to appropriate handler based on event_type:
  - MeetingCreated -> create MeetingProjection
  - TranscriptParsed -> (no direct projection, transcript content comes from events)
  - ActionItemExtracted -> create RaidItemProjection with item_type='action'
  - DecisionExtracted -> create RaidItemProjection with item_type='decision'
  - RiskExtracted -> create RaidItemProjection with item_type='risk'
  - IssueExtracted -> create RaidItemProjection with item_type='issue'

Handlers (private methods):
- `_handle_meeting_created(self, data: dict) -> None`
  Extract aggregate_id as meeting id, title, meeting_date, participant_count
  Call projection_repo.upsert_meeting()

- `_handle_action_item(self, data: dict) -> None`
  Extract action_item_id, meeting_id, description, assignee_name (as owner), due_date, confidence
  Create RaidItemProjection with item_type='action', status='pending'
  Call projection_repo.upsert_raid_item()

- Similar handlers for decision, risk, issue

- `async def rebuild_all(self) -> dict`
  Rebuild all projections from event store:
  1. Clear existing projections (TRUNCATE or DELETE FROM tables)
  2. Iterate through all events via event_store.get_all_events()
  3. Call handle_event for each
  4. Run FTS5 rebuild: `INSERT INTO raid_items_fts(raid_items_fts) VALUES('rebuild')`
  5. Return stats: {"meetings": N, "raid_items": N, "transcripts": N}

Note: For TranscriptParsed events, the transcript text is in the event_data. Parse and insert utterances into transcripts_projection.

**tests/test_projections.py:**
- Test handle_event with MeetingCreated -> creates meeting projection
- Test handle_event with ActionItemExtracted -> creates raid item projection
- Test handle_event with DecisionExtracted, RiskExtracted, IssueExtracted
- Test rebuild_all processes all events and returns stats
- Test unknown event types are ignored (no error)
  </action>
  <verify>
Run tests: `uv run pytest tests/test_projections.py -v`
All tests pass. Events materialize into projections correctly.
  </verify>
  <done>
ProjectionBuilder handles all extraction events. rebuild_all() reprocesses event store. 5+ tests passing.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire projections into event bus</name>
  <files>
    src/main.py
    tests/test_projection_integration.py
  </files>
  <action>
Wire ProjectionBuilder to event bus so projections update automatically.

**src/main.py:**
In the lifespan function, after event store and bus initialization:
1. Import ProjectionRepository, ProjectionBuilder
2. Create projection_repo = ProjectionRepository(db_client)
3. Call await projection_repo.initialize()
4. Create projection_builder = ProjectionBuilder(event_store, projection_repo)
5. Subscribe to event bus with handler that calls projection_builder.handle_event()

Add subscription pattern:
```python
async def projection_handler(event: Event) -> None:
    """Update projections when events occur."""
    await projection_builder.handle_event(event.to_store_dict())

event_bus.subscribe("*", projection_handler)  # Subscribe to all events
```

If EventBus doesn't support wildcard subscription, subscribe to each event type:
- MeetingCreated, TranscriptParsed, ActionItemExtracted, DecisionExtracted, RiskExtracted, IssueExtracted

Store projection_repo and projection_builder in app.state for access by endpoints.

**tests/test_projection_integration.py:**
Integration test:
1. Create meeting via POST /meetings/upload with test transcript
2. Extract RAID items via POST /extraction
3. Verify projections exist in database (query meetings_projection, raid_items_projection)
4. Verify FTS5 search finds the items

Keep test focused - just verify the wiring works.
  </action>
  <verify>
Run tests: `uv run pytest tests/test_projection_integration.py -v`
Integration test passes. Full test suite: `uv run pytest` still passes.
  </verify>
  <done>
ProjectionBuilder wired to event bus. Events automatically update projections. Full pipeline tested end-to-end.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `uv run pytest tests/repositories/test_projection_repo.py tests/test_projections.py tests/test_projection_integration.py -v` - all pass
2. `uv run pytest` - full suite still passes
3. Check tables exist: SQLite introspection shows meetings_projection, raid_items_projection, transcripts_projection, and FTS5 tables
</verification>

<success_criteria>
- Projection tables created with proper schema
- FTS5 indexes created and synchronized via triggers
- ProjectionBuilder handles all RAID extraction events
- Event bus wired to update projections automatically
- rebuild_all() can reconstruct projections from event store
- 15+ new tests passing
</success_criteria>

<output>
After completion, create `.planning/phases/07-cross-meeting-intelligence/07-01-SUMMARY.md`
</output>
