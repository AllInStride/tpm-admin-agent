---
phase: 07-cross-meeting-intelligence
plan: 03
type: execute
wave: 2
depends_on: ["07-01", "07-02"]
files_modified:
  - src/search/fts_service.py
  - src/search/duplicate_detector.py
  - src/api/search.py
  - src/api/router.py
  - tests/test_fts_service.py
  - tests/test_duplicate_detector.py
  - tests/api/test_search.py
autonomous: true

must_haves:
  truths:
    - "User can search across transcript text"
    - "User can search across RAID item descriptions"
    - "Search supports structured filters (type:action owner:john)"
    - "Search results show highlighted snippets"
    - "Potential duplicates surface with similarity scores"
    - "Dashboard endpoint returns grouped open items"
    - "Item history endpoint returns timeline"
  artifacts:
    - path: "src/search/fts_service.py"
      provides: "Full-text search query execution"
      exports: ["FTSService", "SearchResult"]
    - path: "src/search/duplicate_detector.py"
      provides: "RapidFuzz duplicate detection"
      exports: ["DuplicateDetector", "DuplicateMatch"]
    - path: "src/api/search.py"
      provides: "Search API endpoints"
      exports: ["search_router"]
  key_links:
    - from: "src/search/fts_service.py"
      to: "raid_items_fts"
      via: "FTS5 MATCH queries"
      pattern: "MATCH.*raid_items_fts"
    - from: "src/search/duplicate_detector.py"
      to: "rapidfuzz"
      via: "token_set_ratio for similarity"
      pattern: "fuzz\\.token_set_ratio"
    - from: "src/api/search.py"
      to: "src/repositories/open_items_repo.py"
      via: "OpenItemsRepository for dashboard"
      pattern: "OpenItemsRepository"
---

<objective>
Create full-text search service and API endpoints for cross-meeting intelligence.

Purpose: Users need to search across meetings and track open items. This plan creates the FTS5 query service, duplicate detection, and all API endpoints for search and dashboard.

Output: FTSService for search queries, DuplicateDetector using RapidFuzz, API endpoints for search, open-items dashboard, and item history.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-cross-meeting-intelligence/07-CONTEXT.md
@.planning/phases/07-cross-meeting-intelligence/07-RESEARCH.md

# Prior plans (for context on what exists)
@.planning/phases/07-cross-meeting-intelligence/07-01-PLAN.md
@.planning/phases/07-cross-meeting-intelligence/07-02-PLAN.md

# Existing API patterns
@src/api/router.py
@src/api/extraction.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: FTS service and query parsing</name>
  <files>
    src/search/fts_service.py
    src/search/__init__.py (extend)
    tests/test_fts_service.py
  </files>
  <action>
Create FTS5 query service per RESEARCH.md patterns.

**src/search/fts_service.py:**

Create schemas:
`ParsedQuery`:
- keywords: str  # Free text for FTS MATCH
- filters: dict[str, str]  # Structured filters like type:action

`SearchResult`:
- id: str
- source: str  # 'transcript' or 'raid_item'
- meeting_id: str
- snippet: str  # Highlighted context
- relevance: float  # BM25 score
- item_type: str | None  # For RAID items
- speaker: str | None  # For transcripts

`SearchResponse`:
- query: str
- total_results: int
- raid_items: list[SearchResult]
- transcripts: list[SearchResult]

Create `parse_search_query(query: str) -> ParsedQuery`:
Per RESEARCH.md Pattern 3:
```python
import re

def parse_search_query(query: str) -> ParsedQuery:
    """Parse 'type:action owner:john api bug' into structured query."""
    filter_pattern = r'(\w+):(\S+)'
    filters = dict(re.findall(filter_pattern, query))
    keywords = re.sub(filter_pattern, '', query).strip()
    return ParsedQuery(keywords=keywords, filters=filters)
```

Create `FTSService`:
- `__init__(self, db_client: TursoClient)`

- `async def search(self, query: str, limit: int = 50) -> SearchResponse`:
  1. Parse query with parse_search_query()
  2. If keywords exist, search both FTS tables
  3. Apply filters to narrow results
  4. Return combined results

- `async def _search_raid_items(self, parsed: ParsedQuery, limit: int) -> list[SearchResult]`:
  Build FTS5 query:
  ```sql
  SELECT
      r.id,
      r.meeting_id,
      r.item_type,
      snippet(raid_items_fts, 0, '<mark>', '</mark>', '...', 32) as snippet,
      bm25(raid_items_fts) as relevance
  FROM raid_items_fts
  JOIN raid_items_projection r ON raid_items_fts.rowid = r.rowid
  WHERE raid_items_fts MATCH ?
  ```

  Add filter conditions:
  - If 'type' in filters: AND r.item_type = ?
  - If 'owner' in filters: AND r.owner LIKE ?
  - If 'status' in filters: AND r.status = ?

  ORDER BY bm25(raid_items_fts), LIMIT.

  Note: bm25() returns negative values (more negative = more relevant), so ORDER BY bm25(raid_items_fts) ASC.

- `async def _search_transcripts(self, parsed: ParsedQuery, limit: int) -> list[SearchResult]`:
  Similar pattern:
  ```sql
  SELECT
      t.id,
      t.meeting_id,
      t.speaker,
      snippet(transcripts_fts, 1, '<mark>', '</mark>', '...', 32) as snippet,
      bm25(transcripts_fts) as relevance
  FROM transcripts_fts
  JOIN transcripts_projection t ON transcripts_fts.rowid = t.rowid
  WHERE transcripts_fts MATCH ?
  ```

  Add filter conditions:
  - If 'speaker' in filters: AND t.speaker LIKE ?

Important: Escape FTS5 query syntax per RESEARCH.md - wrap keywords in double quotes if they contain special chars, or let FTS5 handle simple terms.

**src/search/__init__.py (extend):**
Add exports: FTSService, SearchResult, SearchResponse, parse_search_query

**tests/test_fts_service.py:**
Setup: Create projection tables and FTS5 tables with test data.
- Test parse_search_query extracts filters correctly
- Test parse_search_query handles query with no filters
- Test parse_search_query handles query with only filters
- Test search returns results from raid_items
- Test search returns results from transcripts
- Test search with type:action filter narrows results
- Test search with owner filter
- Test search returns empty results for no match
- Test search handles special characters gracefully
  </action>
  <verify>
Run tests: `uv run pytest tests/test_fts_service.py -v`
All tests pass. FTS queries execute correctly.
  </verify>
  <done>
FTSService searches both RAID items and transcripts. Query parsing extracts structured filters. Results include highlighted snippets and relevance scores. 9+ tests passing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Duplicate detector</name>
  <files>
    src/search/duplicate_detector.py
    src/search/__init__.py (extend)
    tests/test_duplicate_detector.py
  </files>
  <action>
Create RapidFuzz duplicate detection per RESEARCH.md patterns.

**src/search/duplicate_detector.py:**

Create schemas:
`DuplicateMatch`:
- item_id: str
- description: str
- meeting_id: str
- similarity: float  # 0.0-1.0
- meeting_title: str | None

`DuplicateCheckResult`:
- new_description: str
- potential_duplicates: list[DuplicateMatch]
- has_duplicates: bool  # True if any match above threshold

Create `DuplicateDetector`:
- `__init__(self, db_client: TursoClient, threshold: float = 0.85)`

- `async def find_duplicates(self, description: str, item_type: str | None = None, limit: int = 5) -> DuplicateCheckResult`:
  1. Load existing RAID items from raid_items_projection
     - If item_type provided, filter to same type
     - Load id, description, meeting_id from table

  2. Use RapidFuzz to find similar descriptions:
  ```python
  from rapidfuzz import fuzz, process

  choices = [item['description'] for item in existing_items]

  results = process.extract(
      description,
      choices,
      scorer=fuzz.token_set_ratio,  # Per RESEARCH.md - handles word order
      limit=limit,
      score_cutoff=self.threshold * 100  # rapidfuzz uses 0-100
  )
  ```

  3. Map results back to items and build DuplicateMatch list

  4. Optionally join with meetings_projection for meeting_title

  5. Return DuplicateCheckResult

- `async def record_rejection(self, item_id: str, duplicate_id: str) -> None`:
  Store rejection so we don't re-prompt (per RESEARCH.md Pitfall 4).
  Create table if needed:
  ```sql
  CREATE TABLE IF NOT EXISTS duplicate_rejections (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      item_id TEXT NOT NULL,
      rejected_duplicate_id TEXT NOT NULL,
      created_at TEXT DEFAULT CURRENT_TIMESTAMP,
      UNIQUE(item_id, rejected_duplicate_id)
  )
  ```
  Insert rejection record.

- `async def get_rejections(self, item_id: str) -> set[str]`:
  Return set of duplicate_ids that were rejected for this item.

Modify find_duplicates to exclude rejected duplicates:
  - After getting matches, filter out any in get_rejections(new_item_id) if item_id provided

**src/search/__init__.py (extend):**
Add exports: DuplicateDetector, DuplicateMatch, DuplicateCheckResult

**tests/test_duplicate_detector.py:**
Setup: Create raid_items_projection and meetings_projection with test data.
- Test find_duplicates returns similar items above threshold
- Test find_duplicates returns empty for unique description
- Test find_duplicates with item_type filter
- Test find_duplicates respects threshold (0.9 vs 0.7)
- Test record_rejection stores rejection
- Test find_duplicates excludes rejected duplicates
- Test similarity score is normalized to 0.0-1.0
  </action>
  <verify>
Run tests: `uv run pytest tests/test_duplicate_detector.py -v`
All tests pass. Duplicate detection works correctly.
  </verify>
  <done>
DuplicateDetector finds similar items using RapidFuzz. Rejections can be recorded to avoid re-prompting. 7+ tests passing.
  </done>
</task>

<task type="auto">
  <name>Task 3: Search API endpoints</name>
  <files>
    src/api/search.py
    src/api/router.py (extend)
    tests/api/test_search.py
  </files>
  <action>
Create API endpoints for search, dashboard, and item history.

**src/api/search.py:**
Create FastAPI router:
```python
from fastapi import APIRouter, Depends, Query
search_router = APIRouter(prefix="/search", tags=["search"])
```

Endpoints:

**GET /search**
Query params:
- q: str (required) - Search query
- limit: int = 50

Response: SearchResponse from FTSService.search()

Implementation:
1. Get FTSService from app.state (or create with db dependency)
2. Call fts_service.search(q, limit)
3. Return results

**GET /open-items**
Query params:
- item_type: str | None = None
- owner: str | None = None
- meeting_id: str | None = None
- overdue_only: bool = False
- due_within_days: int | None = None
- group_by: str = 'due_date' (enum: due_date, owner, item_type)

Response: GroupedOpenItems from OpenItemsRepository

Implementation:
1. Build OpenItemFilter from query params
2. Get OpenItemsRepository from app.state
3. Call repo.get_items(filter, group_by)
4. Return results

**GET /open-items/summary**
No params.
Response: OpenItemSummary

Implementation:
1. Get OpenItemsRepository from app.state
2. Call repo.get_summary()
3. Return results

**POST /items/{item_id}/close**
Path param: item_id
Body (optional): {"status": "completed"} - default "completed"

Response: {"success": bool, "item_id": str, "new_status": str}

Implementation:
1. Get OpenItemsRepository from app.state
2. Call repo.close_item(item_id, status)
3. Return result

**GET /items/{item_id}/history**
Path param: item_id

Response: ItemHistory

Implementation:
1. Get OpenItemsRepository from app.state
2. Call repo.get_item_history(item_id)
3. If None, raise HTTPException(404)
4. Return history

**POST /items/check-duplicates**
Body: {"description": str, "item_type": str | None}

Response: DuplicateCheckResult

Implementation:
1. Get DuplicateDetector from app.state
2. Call detector.find_duplicates(description, item_type)
3. Return result

**POST /items/{item_id}/reject-duplicate**
Path param: item_id
Body: {"duplicate_id": str}

Response: {"success": bool}

Implementation:
1. Get DuplicateDetector from app.state
2. Call detector.record_rejection(item_id, duplicate_id)
3. Return success

**src/api/router.py (extend):**
Import search_router and include it:
```python
from src.api.search import search_router
api_router.include_router(search_router)
```

**src/main.py (extend):**
In lifespan, after projection setup:
1. Create FTSService(db_client)
2. Create DuplicateDetector(db_client)
3. Create OpenItemsRepository(db_client)
4. Store all in app.state

**tests/api/test_search.py:**
Use TestClient with mocked services.
- Test GET /search returns results
- Test GET /search with empty query returns 422
- Test GET /open-items returns grouped items
- Test GET /open-items with filters
- Test GET /open-items/summary returns counts
- Test POST /items/{id}/close updates status
- Test POST /items/{id}/close returns 404 for missing
- Test GET /items/{id}/history returns timeline
- Test GET /items/{id}/history returns 404 for missing
- Test POST /items/check-duplicates returns matches
- Test POST /items/{id}/reject-duplicate stores rejection
  </action>
  <verify>
Run tests: `uv run pytest tests/api/test_search.py -v`
All tests pass. `uv run pytest` - full suite passes.
  </verify>
  <done>
All search and dashboard API endpoints working. GET /search for full-text search. GET /open-items for dashboard. GET /items/{id}/history for timeline. Duplicate detection endpoints. 11+ tests passing.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `uv run pytest tests/test_fts_service.py tests/test_duplicate_detector.py tests/api/test_search.py -v` - all pass
2. `uv run pytest` - full suite passes (400+ tests)
3. Manual verification:
   - `curl -X GET "http://localhost:8000/search?q=deadline"`
   - `curl -X GET "http://localhost:8000/open-items?group_by=owner"`
   - `curl -X GET "http://localhost:8000/open-items/summary"`
</verification>

<success_criteria>
- GET /search returns FTS5 results with snippets and relevance
- Structured filter syntax (type:action owner:john) works
- GET /open-items returns grouped open items
- GET /open-items/summary returns dashboard counts
- POST /items/{id}/close updates item status
- GET /items/{id}/history returns timeline with meeting context
- POST /items/check-duplicates finds similar items
- All endpoints documented in OpenAPI schema
- 25+ new tests passing
</success_criteria>

<output>
After completion, create `.planning/phases/07-cross-meeting-intelligence/07-03-SUMMARY.md`
</output>
