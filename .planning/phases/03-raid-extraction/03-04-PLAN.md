---
phase: 03-raid-extraction
plan: 04
type: execute
wave: 3
depends_on: ["03-03"]
files_modified:
  - src/api/meetings.py
  - src/api/extraction.py
  - src/api/router.py
  - tests/api/test_extraction.py
autonomous: true

must_haves:
  truths:
    - "User can trigger extraction for a meeting via API"
    - "Extraction emits events for each RAID item extracted"
    - "MeetingProcessed event summarizes extraction results"
    - "API returns extraction summary with counts and items"
  artifacts:
    - path: "src/api/extraction.py"
      provides: "Extraction API endpoint"
      exports: ["router"]
    - path: "tests/api/test_extraction.py"
      provides: "Integration tests for extraction endpoint"
      min_lines: 50
  key_links:
    - from: "src/api/extraction.py"
      to: "src/services/raid_extractor.py"
      via: "dependency injection"
      pattern: "RAIDExtractor"
    - from: "src/api/extraction.py"
      to: "src/events/bus.py"
      via: "event emission"
      pattern: "publish_and_store"
    - from: "src/api/router.py"
      to: "src/api/extraction.py"
      via: "router include"
      pattern: "include_router.*extraction"
---

<objective>
Create extraction API endpoint that triggers RAID extraction and emits events for extracted items.

Purpose: Expose extraction as an API operation, emit events for downstream processing, complete the extraction pipeline.
Output: POST /meetings/{meeting_id}/extract endpoint returning extraction summary with event emission
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-raid-extraction/03-RESEARCH.md
@src/services/raid_extractor.py (from 03-03)
@src/events/types.py
@src/events/bus.py
@src/api/meetings.py
@src/api/router.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create extraction endpoint</name>
  <files>
    - src/api/extraction.py
    - src/api/router.py
  </files>
  <action>
1. Create src/api/extraction.py:

   Response models:
   - ExtractedItemSummary: id (UUID), description (str), confidence (float)
   - ExtractionResponse:
     * meeting_id: UUID
     * action_items: list[ExtractedItemSummary]
     * decisions: list[ExtractedItemSummary]
     * risks: list[ExtractedItemSummary]
     * issues: list[ExtractedItemSummary]
     * total_extracted: int
     * processing_time_ms: int

   Dependencies:
   - get_raid_extractor() -> RAIDExtractor: Creates RAIDExtractor with LLMClient from settings
   - Use existing get_event_bus dependency from meetings.py

   Endpoint:
   - POST /meetings/{meeting_id}/extract
   - Path param: meeting_id (UUID)
   - Query param: confidence_threshold (float, default=0.5, ge=0.0, le=1.0)
   - Response: ExtractionResponse

   Implementation:
   a. Start timer
   b. TODO for now: For MVP, accept transcript_text in request body (later will fetch from event store)
      - Request body: ExtractionRequest with transcript_text (str) and meeting_date (datetime)
   c. Create RAIDExtractor with provided confidence_threshold
   d. Call extractor.extract_all(transcript_text, meeting_id, meeting_date)
   e. For each extracted item, emit corresponding event:
      - ActionItemExtracted for each action item
      - DecisionExtracted for each decision
      - RiskExtracted for each risk
      - IssueExtracted for each issue
   f. Emit MeetingProcessed event with counts
   g. Calculate processing_time_ms
   h. Return ExtractionResponse with items and timing

2. Update src/api/router.py:
   - Import extraction router
   - Include with prefix="/meetings" (extraction is a sub-operation of meetings)
  </action>
  <verify>
    - `python -c "from src.api.extraction import router; print('OK')"` succeeds
    - Server starts: `uvicorn src.main:app --host 0.0.0.0 --port 8000` (check briefly, then stop)
    - Endpoint appears in OpenAPI: curl http://localhost:8000/docs shows /meetings/{meeting_id}/extract
  </verify>
  <done>Extraction endpoint created, router integrated, events emitted for each extracted item</done>
</task>

<task type="auto">
  <name>Task 2: Integration tests for extraction endpoint</name>
  <files>
    - tests/api/test_extraction.py
  </files>
  <action>
Create tests/api/test_extraction.py:

1. Fixtures:
   - client: TestClient for FastAPI app
   - mock_llm_client: AsyncMock returning controlled extraction results
   - mock_event_bus: AsyncMock for EventBus
   - sample_transcript_text: Realistic multi-speaker transcript excerpt
   - sample_meeting_id: Fixed UUID
   - sample_meeting_date: Fixed datetime

2. Test successful extraction:
   - POST /meetings/{meeting_id}/extract with transcript_text and meeting_date
   - Mock LLM to return 2 action items, 1 decision, 1 risk, 1 issue
   - Verify response has correct counts (total_extracted: 5)
   - Verify response includes item summaries with IDs and confidence

3. Test event emission:
   - Same as above, but verify mock_event_bus.publish_and_store called:
     * 2x ActionItemExtracted
     * 1x DecisionExtracted
     * 1x RiskExtracted
     * 1x IssueExtracted
     * 1x MeetingProcessed
   - Verify MeetingProcessed has correct counts

4. Test confidence threshold filtering:
   - POST with confidence_threshold=0.8
   - Mock LLM returns items with confidence 0.6, 0.7, 0.8, 0.9
   - Verify only 0.8 and 0.9 items in response

5. Test empty extraction:
   - Mock LLM returns empty lists
   - Verify response with all zeros
   - Verify MeetingProcessed event has all zero counts

6. Test invalid meeting_id format:
   - POST with invalid UUID string
   - Verify 422 validation error

7. Test missing request body:
   - POST without transcript_text
   - Verify 422 validation error

Note: These tests mock the LLM client, not actual API calls. Real LLM integration tested manually or via separate integration test suite.
  </action>
  <verify>
    - `pytest tests/api/test_extraction.py -v` all tests pass
    - At least 6 tests covering success, events, filtering, edge cases
  </verify>
  <done>Extraction endpoint tested with mocked LLM, event emission verified, edge cases covered</done>
</task>

</tasks>

<verification>
- Endpoint accessible: Start server, `curl -X POST http://localhost:8000/meetings/{uuid}/extract`
- Tests pass: `pytest tests/api/test_extraction.py -v`
- Full test suite: `pytest tests/ -v` (all existing tests still pass)
</verification>

<success_criteria>
- POST /meetings/{meeting_id}/extract triggers RAID extraction
- Events emitted for each extracted item (ActionItemExtracted, etc.)
- MeetingProcessed event summarizes extraction
- Response includes item counts and summaries
- Confidence threshold configurable via query param
- Integration tests verify full flow with mocked LLM
</success_criteria>

<output>
After completion, create `.planning/phases/03-raid-extraction/03-04-SUMMARY.md`
</output>
